<script>
  const { createApp, ref, computed, onMounted, onUnmounted, watch, watchEffect, nextTick } = Vue;

  createApp({
    setup() {
      // Vue 3 Composition APIÏóêÏÑúÎäî DOM Ï∞∏Ï°∞Î•º ÏúÑÌï¥ refÎ•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.
      const kebabButton = ref(null); // [NEW] ÏºÄÎ∞• Î≤ÑÌäº DOM ÏöîÏÜå Ï∞∏Ï°∞Ïö©

      // --- Constants ---
      const GOOGLE_SHEET_URL = 'https://docs.google.com/spreadsheets/d/1Zs610z6VE5AxeaJblNM8zRDu8fbGgn82F3nR7OId3ok/';
      const appElement = document.getElementById('app');
      const BASE_WEBAPP_URL = appElement ? appElement.dataset.appUrl : '';

      // --- State ---
      const restaurants = ref([]);
      const allReviews = ref([]);
      const currentTab = ref('list');
      const pageSize = ref(30);
      const currentPage = ref(1);

      const windowWidth = ref(window.innerWidth);
      const currentUser = ref({ email: '', isAdmin: false });
      const isLoading = ref(true);
      const loadingText = ref('ÏÇ¨Î¨¥Ïã§ Í∑ºÏ≤ò ÎßõÏßë Ï†ïÎ≥¥ÏôÄ ÏÜîÏßÅ Î¶¨Î∑∞ Î∂àÎü¨Ïò§Îäî Ï§ë... üöÄ');
      const loadingInterval = ref(null); // [NEW] ÌÉÄÏù¥Î®∏ ID Ï†ÄÏû•
      const currentPhraseIndex = ref(0); // [NEW] ÌòÑÏû¨ Î¨∏Íµ¨ Ïù∏Îç±Ïä§

      // [NEW] Î°úÎî© Î¨∏Íµ¨ Î¶¨Ïä§Ìä∏ Ï†ïÏùò
      const LOADING_PHRASES = [
        'ÏÇ¨Î¨¥Ïã§ Í∑ºÏ≤ò ÎßõÏßë Ï†ïÎ≥¥ÏôÄ ÏÜîÏßÅ Î¶¨Î∑∞ Î∂àÎü¨Ïò§Îäî Ï§ë... üöÄ',
        'Î£∞Î£®ÎûÑÎùº ÎπÖÎç∞Ïù¥ÌÑ∞ ÏÜçÏùÑ Ìó§ÏóÑÏπòÎäî Ï§ë...üêü',
        'ÏÉàÎ°úÏö¥ ÍøÄÌåÅ Î¶¨Î∑∞Î•º ÏàòÏßëÌïòÍ≥† ÏûàÏäµÎãàÎã§. üçØ',
        'ÏßÄÎèÑ Îç∞Ïù¥ÌÑ∞Î•º ÎèôÍ∏∞ÌôîÌïòÍ≥† ÏûàÏäµÎãàÎã§. üó∫Ô∏è',
        'Ï∞ú Î™©Î°ùÍ≥º Î¶¨Î∑∞ Í∏∞Î°ùÏùÑ ÌôïÏù∏ Ï§ëÏûÖÎãàÎã§. ‚ù§Ô∏è',
        'Î¶¨Î∑∞ ÌèâÏ†ê ÌÜµÍ≥ÑÎ•º Í≥ÑÏÇ∞ÌïòÍ≥† ÏûàÏäµÎãàÎã§. ‚ú®',
        'Îç∞Ïù¥ÌÑ∞Î•º ÏµúÏ†ÅÌôîÌïòÍ≥† ÏûàÏäµÎãàÎã§. Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî. üìä',
        'Ïò§ÎäòÏùò Î©îÎâ¥ Ï∂îÏ≤úÏùÑ Ï§ÄÎπÑ Ï§ë... üçú',
      ];

      const RANK_TIERS = [
        { name: 'ÏïÑÏù¥Ïñ∏', min: 0, max: 0, nextMin: 1, icon: 'ph ph-crown-simple', color: 'text-gray-500' },
        { name: 'Î∏åÎ°†Ï¶à', min: 1, max: 9, nextMin: 10, icon: 'ph-fill ph-crown-simple', color: 'text-amber-700' },
        { name: 'Ïã§Î≤Ñ', min: 10, max: 29, nextMin: 30, icon: 'ph-fill ph-crown-simple', color: 'text-gray-400' },
        { name: 'Í≥®Îìú', min: 30, max: 49, nextMin: 50, icon: 'ph-fill ph-crown-simple', color: 'text-yellow-500' },
        { name: 'ÌîåÎûòÌã∞ÎÑò', min: 50, max: 69, nextMin: 70, icon: 'ph-fill ph-crown', color: 'text-sky-400' },
        { name: 'Îã§Ïù¥ÏïÑÎ™¨Îìú', min: 70, max: 99, nextMin: 100, icon: 'ph-fill ph-diamond', color: 'text-blue-500' },
        { name: 'Î∏îÎûô Îã§Ïù¥ÏïÑÎ™¨Îìú', min: 100, max: Infinity, nextMin: 100, icon: 'ph-fill ph-diamond', color: 'text-gray-900 bg-gray-100' },
      ];

      const showUserModal = ref(false);

      const isFilterOpen = ref(false);
      const filters = ref({ categories: [], tags: [], minRate: 0, maxPrice: 0 });
      const showLikeFilter = ref(false);
      const showMyReviewsFilter = ref(false);
      const showPendingReviewsFilter = ref(false);
      const searchQuery = ref('');

      const sort = ref({ field: 'name', order: 'asc' });

      // [Ï∂îÍ∞Ä] Î™®Î∞îÏùº/Îç∞Ïä§ÌÅ¨ÌÉë ÎìúÎ°≠Îã§Ïö¥ Ï†úÏñ¥ ÏÉÅÌÉú
      const sortDropdownOpen = ref(false);
      const pageSizeDropdownOpen = ref(false);

      const userLikes = ref(new Set());

      const myReviewedRestaurantIds = ref(new Set());
      const menuMap = ref({}); // [NEW] Î©îÎâ¥ Ï∫êÏã± ÏÉÅÌÉú Ï∂îÍ∞Ä

      const modalOpen = ref(false);
      const modalMode = ref('view');
      const selectedRestaurant = ref({});

      const restaurantForm = ref({ id: '', name: '', category: '', tags: [], signature_menu: '', price: '', tagInput: '', menus: [] });

      const duplicateList = ref([]);

      const showCategoryDropdown = ref(false);
      const focusedCategoryIndex = ref(-1);

      // Reviews State
      const reviews = ref([]);
      const isSubmitting = ref(false);
      const highlightReviewId = ref(null);
      const reviewForm = ref({ rate: 0, user_name: '', comment: '' });
      const hoverRate = ref(0);
      const editingReviewId = ref(null);
      const editForm = ref({ id: '', rate: 0, comment: '' });
      const isReviewSubmitting = ref(false);

      const alertState = ref({ visible: false, type: 'alert', title: '', message: '', resolve: null });

      // [NEW] ÏºÄÎ∞• Î©îÎâ¥ ÏÉÅÌÉú
      const showKebabMenu = ref(false);

      // Tooltip & Wheel State
      const tooltipVisible = ref(false);
      const tooltipData = ref({});
      const tooltipPos = ref({ x: 0, y: 0 });
      const wheelItems = ref([]);
      const wheelSearch = ref('');
      const isSpinning = ref(false);
      const winner = ref(null);
      const isWheelListExpanded = ref(true);
      const isComposing = ref(false);

      const myPageTab = ref('info');

      let wheelRotation = 0;
      let wheelVelocity = 0;
      let animationId = null;
      let prevIndex = 0;
      let pinAngle = 0;
      let pinVelocity = 0;
      let pinSpring = 0.2;
      let pinDamping = 0.94;
      let pinKick = 0.15;
      let pinDrag = 0.8;

      // --- Computed ---
      const uniqueCategories = computed(() => {
        const cats = new Set(restaurants.value.map(r => r.category));
        return Array.from(cats).sort();
      });
      const uniqueTags = computed(() => {
        const tags = new Set();
        restaurants.value.forEach(r => r.tags.forEach(t => tags.add(t)));
        return Array.from(tags).sort();
      });

      const isNewCategory = computed(() => {
        const cat = restaurantForm.value.category;
        return cat && !uniqueCategories.value.includes(cat);
      });

      const filteredCategoryOptions = computed(() => {
        const input = (restaurantForm.value.category || '').replace(/\s/g, '').toLowerCase();
        if (!input) return uniqueCategories.value;
        return uniqueCategories.value.filter(cat => cat.replace(/\s/g, '').toLowerCase().includes(input));
      });

      const filteredRestaurants = computed(() => {
        let result = restaurants.value.filter(r => {
          if (Number(r.rate) < filters.value.minRate) return false;
          if (filters.value.categories.length > 0 && !filters.value.categories.includes(r.category)) return false;
          if (filters.value.tags.length > 0 && !r.tags.some(t => filters.value.tags.includes(t))) return false;

          const priceValue = Number(r.price || 0); // r.priceÍ∞Ä Ïà´ÏûêÎùºÍ≥† Í∞ÄÏ†ï
          if (filters.value.maxPrice > 0 && priceValue > 0 && priceValue > filters.value.maxPrice) {
            return false;
          }

          // [NEW] Ï¢ãÏïÑÏöî ÌïÑÌÑ∞ Ï†ÅÏö©
          if (showLikeFilter.value) {
            if (!userLikes.value.has(r.id)) return false;
          }

          // [NEW] ÎÇ¥Í∞Ä Î¶¨Î∑∞ ÎÇ®Í∏¥ ÏãùÎãπ ÌïÑÌÑ∞ (Ï∫êÏã±Îêú Set ÏÇ¨Ïö©)
          if (showMyReviewsFilter.value) {
            if (!myReviewedRestaurantIds.value.has(r.id)) return false;
          }

          // [NEW] ÎÇ¥ Î¶¨Î∑∞Î•º Í∏∞Îã§Î¶¨Îäî ÏãùÎãπ ÌïÑÌÑ∞ (ÎÇ¥Í∞Ä Î¶¨Î∑∞ ÎÇ®Í∏∞ÏßÄ ÏïäÏùÄ ÏãùÎãπ)
          if (showPendingReviewsFilter.value) {
            if (myReviewedRestaurantIds.value.has(r.id)) return false;
          }

          if (searchQuery.value) {
            const query = searchQuery.value.replace(/\s/g, '').toLowerCase();
            const targetName = r.name.replace(/\s/g, '').toLowerCase();
            if (!targetName.includes(query)) return false;
          }

          return true;
        });

        if (sort.value.order) {
          result.sort((a, b) => {
            let valA = a[sort.value.field];
            let valB = b[sort.value.field];
            if (typeof valA === 'string') valA = valA.toLowerCase();
            if (typeof valB === 'string') valB = valB.toLowerCase();

            if (sort.value.field === 'rate') {
              valA = Number(a.rate || 0); valB = Number(b.rate || 0);
            } else if (sort.value.field === 'review_count') {
              valA = Number(a.review_count || 0); valB = Number(b.review_count || 0);
            } else if (sort.value.field === 'like_count') {
              valA = Number(a.like_count || 0); valB = Number(b.like_count || 0);
            } else if (sort.value.field === 'price') { // [NEW] Í∞ÄÍ≤©Ïàú Ï†ïÎ†¨ (Ïà´Ïûê ÎπÑÍµê)
              valA = Number(a.price || 0); valB = Number(b.price || 0);
            }

            if (valA < valB) return sort.value.order === 'asc' ? -1 : 1;
            if (valA > valB) return sort.value.order === 'asc' ? 1 : -1;
            return 0;
          });
        }
        return result;
      });
      const totalPages = computed(() => Math.ceil(filteredRestaurants.value.length / pageSize.value));
      const paginatedRestaurants = computed(() => {
        const start = (currentPage.value - 1) * pageSize.value;
        const end = start + pageSize.value;
        return filteredRestaurants.value.slice(start, end);
      });
      const filteredWheelCandidates = computed(() => {
        if (!wheelSearch.value) return [];
        const term = wheelSearch.value.replace(/\s/g, '').toLowerCase();
        return restaurants.value.filter(r => r.name.replace(/\s/g, '').toLowerCase().includes(term));
      });

      const userId = computed(() => {
        if (!currentUser.value.email) return '';
        const atIndex = currentUser.value.email.indexOf('@');
        return atIndex > 0 ? currentUser.value.email.substring(0, atIndex) : currentUser.value.email;
      });

      const userInitial = computed(() => {
        return (currentUser.value && currentUser.value.email) ? currentUser.value.email.charAt(0).toUpperCase() : '?';
      });

      const userReviewCount = computed(() => {
        if (!currentUser.value.email || allReviews.value.length === 0) return 0;
        return allReviews.value.filter(review => String(review.user_email) === String(currentUser.value.email)).length;
      });

      const userRankInfo = computed(() => {
        if (isLoading.value) return null;
        const count = userReviewCount.value;

        const currentRank = RANK_TIERS.slice().reverse().find(tier => count >= tier.min);

        if (!currentRank) {
          return RANK_TIERS[0];
        }

        const isMaxRank = currentRank.max === Infinity;

        let percentageValue = 0;
        let targetCount = currentRank.nextMin;
        let nextRankName = '';
        let nextRankIcon = '';
        let nextRankColor = '';

        if (!isMaxRank) {
          const currentMin = currentRank.min;
          const totalReviewsNeeded = targetCount - currentMin;
          const reviewsDoneInTier = count - currentMin;

          if (totalReviewsNeeded > 0) {
            percentageValue = (reviewsDoneInTier / totalReviewsNeeded) * 100;
          }
          percentageValue = Math.min(99, Math.floor(percentageValue));

          const nextRankIndex = RANK_TIERS.findIndex(tier => tier.min === currentRank.nextMin);
          if (nextRankIndex !== -1) {
            nextRankName = RANK_TIERS[nextRankIndex].name;
            nextRankIcon = RANK_TIERS[nextRankIndex].icon;
            nextRankColor = RANK_TIERS[nextRankIndex].color;
          }

        } else {
          targetCount = count;
          percentageValue = 100;
        }

        // 4. ÏµúÏ¢Ö Í≤∞Í≥º Î∞òÌôò
        return {
          name: currentRank.name,
          icon: currentRank.icon,
          color: currentRank.color,

          reviewCount: count,
          targetCount: targetCount,
          percentage: percentageValue,
          isMaxRank: isMaxRank,

          // [NEW] Îã§Ïùå Îû≠ÌÅ¨ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
          nextRankName: nextRankName,
          nextRankIcon: nextRankIcon,
          nextRankColor: nextRankColor,
        };
      });

      const currentRestaurantMenus = computed(() => {
        const restaurantId = selectedRestaurant.value?.id;
        // selectedRestaurant.value.idÏôÄ menuMap.valueÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Î©îÎâ¥ Îç∞Ïù¥ÌÑ∞Ïóê Ï†ëÍ∑ºÌï©ÎãàÎã§.
        if (restaurantId && menuMap.value[String(restaurantId)]) {
          return menuMap.value[String(restaurantId)];
        }
        return [];
      });

      const sortedMenus = computed(() => {
        const menus = currentRestaurantMenus.value;
        if (!menus || menus.length === 0) return [];

        // Ï†ïÎ†¨ Î°úÏßÅ: is_signatureÍ∞Ä trueÏù∏ Î©îÎâ¥Í∞Ä falseÏù∏ Î©îÎâ¥Î≥¥Îã§ ÏïûÏóê Ïò§ÎèÑÎ°ù Ï†ïÎ†¨Ìï©ÎãàÎã§.
        // (b.is_signature - a.is_signature)Îäî true(1)Î•º false(0)Î≥¥Îã§ ÌÅ¨Í≤å Ï≤òÎ¶¨ÌïòÏó¨ ÎÇ¥Î¶ºÏ∞®Ïàú Ï†ïÎ†¨ Ìö®Í≥ºÎ•º ÎÉÖÎãàÎã§.
        return [...menus].sort((a, b) => {
          return (b.is_signature - a.is_signature);
        });
      });

      const calculatedPriceDisplay = computed(() => {
        // restaurantForm.menusÎ•º Í∞êÏãúÌïòÏó¨ ÌèâÍ∑† Í∞ÄÍ≤©ÏùÑ Í≥ÑÏÇ∞
        return calculateAvgPrice(restaurantForm.value.menus);
      });

      const myLikedRestaurants = computed(() => {
        // userLikes SetÏóê IDÍ∞Ä Ìè¨Ìï®Îêú ÏãùÎãπÎßå ÌïÑÌÑ∞ÎßÅÌï©ÎãàÎã§.
        const liked = restaurants.value.filter(r => userLikes.value.has(r.id));

        // ÏÑúÎ≤ÑÏóêÏÑú Ï¢ãÏïÑÏöî Ï†ïÎ≥¥Í∞Ä Î°úÎìúÎê† Îïå created_at Ï†ïÎ≥¥ÎèÑ Ìï®Íªò Ïò®Îã§Í≥† Í∞ÄÏ†ïÌïòÍ≥† Ï†ïÎ†¨Ìï©ÎãàÎã§.
        // ÎßåÏïΩ rest Í∞ùÏ≤¥Ïóê Ï¢ãÏïÑÏöî Í¥ÄÎ†® created_atÏù¥ ÏóÜÎã§Î©¥, Í∑∏ÎÉ• Î¶¨Ïä§Ìä∏ ÏàúÏÑúÎåÄÎ°ú Î∞òÌôòÌï©ÎãàÎã§.
        return liked;

        // NOTE: ÌòÑÏû¨ JS ÏΩîÎìúÏóêÏÑúÎäî Í∞úÎ≥Ñ ÏãùÎãπ(rest) Í∞ùÏ≤¥Ïóê ÏÇ¨Ïö©ÏûêÏùò 'Ï¢ãÏïÑÏöî ÏãúÏ†ê(created_at)' Ï†ïÎ≥¥Í∞Ä ÏßÅÏ†ë Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§.
        // Ï¢ãÏïÑÏöîÎäî Set(IDÎßå)ÏúºÎ°ú Í¥ÄÎ¶¨ÎêòÎØÄÎ°ú, ÏÑúÎ≤ÑÏóêÏÑú Ï¢ãÏïÑÏöî Î™©Î°ùÏùÑ Í∞ÄÏ†∏Ïò¨ Îïå ÏãúÏ†ê Ï†ïÎ≥¥Î•º Ìè¨Ìï®ÌïòÎèÑÎ°ù API ÏàòÏ†ïÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.
        // ÏûÑÏãúÎ°ú, Î¶¨Ïä§Ìä∏Ïóê ÎÇòÌÉÄÎÇòÎäî ÏàúÏÑúÎåÄÎ°ú Î∞òÌôòÌï©ÎãàÎã§.
      });

      // [ÏàòÏ†ï] ÎÇ¥ Î¶¨Î∑∞ Î¶¨Ïä§Ìä∏ (ÏµúÏã† Î¶¨Î∑∞ Ïàú Ï†ïÎ†¨)
      const myReviews = computed(() => {
        if (!currentUser.value.email) return [];

        // 1. ÎÇ¥Í∞Ä ÏûëÏÑ±Ìïú Î™®Îì† Î¶¨Î∑∞Î•º Í∞ÄÏ†∏ÏôÄÏÑú Ï†ïÎ†¨Ìï©ÎãàÎã§. (ÏµúÏã† updated_at Ïàú)
        const reviewsByUser = allReviews.value.filter(
          r => String(r.user_email) === String(currentUser.value.email)
        ).sort((a, b) => {
          const timeA = new Date(b.updated_at || b.created_at).getTime();
          const timeB = new Date(a.updated_at || a.created_at).getTime();
          return timeA - timeB;
        });

        // 2. Í∞Å Î¶¨Î∑∞Ïóê Ìï¥ÎãπÌïòÎäî ÏãùÎãπ Ï†ïÎ≥¥Î•º Ï∞æÏïÑÏÑú ÌïÑÎìúÎ•º Î™ÖÌôïÌûà Ìï©ÎãàÎã§.
        return reviewsByUser.map(review => {
          const restaurant = restaurants.value.find(r => r.id === review.restaurant_id);

          // ÏãùÎãπ Ï†ïÎ≥¥Í∞Ä ÏóÜÍ±∞ÎÇò Î∂ÄÏ°±Ìï† Í≤ΩÏö∞Î•º ÎåÄÎπÑÌïú Í∏∞Î≥∏Í∞í
          const restInfo = restaurant || { name: 'ÏÇ≠Ï†úÎêú ÏãùÎãπ', category: 'N/A', rate: 0, like_count: 0, price: 0 };

          return {
            // Î∑∞Ïóê ÌïÑÏöîÌïú ÏãùÎãπ Ï†ïÎ≥¥
            restaurant_id: restInfo.id,
            name: restInfo.name,
            category: restInfo.category,
            like_count: restInfo.like_count,
            rate: restInfo.rate, // ÏãùÎãπ ÌèâÍ∑† ÌèâÏ†ê

            // Î∑∞Ïóê ÌïÑÏöîÌïú Ìï¥Îãπ Î¶¨Î∑∞ Ï†ïÎ≥¥
            id: review.id, // Ïπ¥ÎìúÏùò Í≥†Ïú† ÌÇ§ (Î¶¨Î∑∞ ID)
            review_rate: review.rate, // Ïù¥ Ïπ¥ÎìúÍ∞Ä Î≥¥Ïó¨Ï§Ñ 'ÎÇòÏùò' Í∞úÎ≥Ñ ÌèâÏ†ê
            comment: review.comment, // [ÏàòÏ†ï] Ïù¥ Ïπ¥ÎìúÍ∞Ä Î≥¥Ïó¨Ï§Ñ 'ÎÇòÏùò' Î¶¨Î∑∞ ÎÇ¥Ïö©
            updated_at: review.updated_at || review.created_at, // Ïπ¥ÎìúÏóê ÌëúÏãúÌï† ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÍ∞Ñ
          };
        });
      });

      const isMobile = computed(() => {
        return windowWidth.value < 768;
      });

      // --- Internal Helpers (Data Sync) ---
      const updateReviewAndRestaurantState = (restId, newReview = null, deletedReviewId = null) => {
        const rest = restaurants.value.find(r => r.id === restId);
        if (!rest) return;

        // 1. All Reviews ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (Ï∂îÍ∞Ä/ÏÇ≠Ï†ú/ÏàòÏ†ï)
        if (newReview) {
          const index = allReviews.value.findIndex(r => r.id === newReview.id);
          if (index !== -1) {
            allReviews.value.splice(index, 1, newReview);
          } else {
            allReviews.value.unshift(newReview);
          }
        } else if (deletedReviewId) {
          const index = allReviews.value.findIndex(r => r.id === deletedReviewId);
          if (index !== -1) {
            allReviews.value.splice(index, 1);
          }
        }

        // 2. Î¶¨Î∑∞ Ïπ¥Ïö¥Ìä∏ Î∞è ÌèâÏ†ê Ïû¨Í≥ÑÏÇ∞
        const filteredReviews = allReviews.value.filter(r => String(r.restaurant_id) === String(restId));
        const count = filteredReviews.length;
        const sum = filteredReviews.reduce((acc, curr) => acc + Number(curr.rate), 0);
        const avg = count > 0 ? parseFloat((sum / count).toFixed(1)) : 0;

        rest.review_count = count;
        rest.rate = avg;
        rest.latestReview = filteredReviews[0]?.comment || null;
        rest.latestReviewRate = filteredReviews[0]?.rate || null;

        // 3. ÌòÑÏû¨ Î™®Îã¨ Î¶¨Î∑∞ Î∞è ÌïÑÌÑ∞ Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
        updateCurrentModalReviews(restId);
        updateReviewFilterCache(restId, newReview ? newReview.user_email : currentUser.value.email, deletedReviewId);
      };

      const updateReviewFilterCache = (restId, userEmail, deletedReviewId) => {
        if (userEmail === currentUser.value.email) {
          if (!deletedReviewId) {
            myReviewedRestaurantIds.value.add(restId);
          } else {
            const remaining = allReviews.value.some(r => String(r.restaurant_id) === String(restId) && String(r.user_email) === String(userEmail));
            if (!remaining) {
              myReviewedRestaurantIds.value.delete(restId);
            }
          }
        }
      };

      const updateRestaurantLocalState = (serverData, isEdit) => {
        const existingRest = isEdit ? restaurants.value.find(r => r.id === serverData.id) : null;

        const newRestaurant = {
          id: serverData.id,
          name: restaurantForm.value.name,
          category: restaurantForm.value.category,
          tags: restaurantForm.value.tags,
          signature_menu: serverData.signature_menu, // [ÏàòÏ†ï] ÏÑúÎ≤ÑÏóêÏÑú Ïò® ÏãúÍ∑∏ÎãàÏ≤ò Î©îÎâ¥Î™Ö ÏÇ¨Ïö©
          price: serverData.price, // [ÏàòÏ†ï] ÏÑúÎ≤ÑÏóêÏÑú Ïò® ÌèâÍ∑† Í∞ÄÍ≤© ÏÇ¨Ïö©
          rate: existingRest ? existingRest.rate : 0,
          like_count: existingRest ? existingRest.like_count : 0,
          review_count: existingRest ? existingRest.review_count : 0,
          // enabled, created_at, updated_at ÌïÑÎìúÎäî ÏÑúÎ≤ÑÏóêÏÑú Í¥ÄÎ¶¨ÎêúÎã§Í≥† Í∞ÄÏ†ï
        };

        if (isEdit) {
          const index = restaurants.value.findIndex(r => r.id === serverData.id);
          if (index !== -1) {
            const currentRest = restaurants.value[index];
            restaurants.value.splice(index, 1, { ...currentRest, ...newRestaurant });
            selectedRestaurant.value = restaurants.value[index];
          }
        } else {
          restaurants.value.unshift(newRestaurant);
          selectedRestaurant.value = newRestaurant;
        }
      };

      // -------------------------------

      // --- Methods ---
      const showAlert = (message, title = 'ÏïåÎ¶º') => {
        return new Promise(resolve => { alertState.value = { visible: true, type: 'alert', title, message, resolve }; });
      };
      const showConfirm = (message, title = 'ÌôïÏù∏') => {
        return new Promise(resolve => { alertState.value = { visible: true, type: 'confirm', title, message, resolve }; });
      };
      const onAlertConfirm = () => { if (alertState.value.resolve) alertState.value.resolve(true); alertState.value.visible = false; };
      const onAlertCancel = () => { if (alertState.value.resolve) alertState.value.resolve(false); alertState.value.visible = false; };

      const startLoadingAnimation = (intervalTime = 5000) => {
        if (loadingInterval.value) return;

        const phraseLength = LOADING_PHRASES.length;

        // ÏµúÏ¥à Î¨∏Íµ¨ ÏÑ§Ï†ï
        loadingText.value = LOADING_PHRASES[0];

        loadingInterval.value = setInterval(() => {
          // ÌòÑÏû¨ Î¨∏Íµ¨ÏôÄ Îã§Î•∏ ÏÉàÎ°úÏö¥ Î¨¥ÏûëÏúÑ Ïù∏Îç±Ïä§ ÏÑ†ÌÉù
          let newIndex;
          do {
            newIndex = Math.floor(Math.random() * phraseLength);
          } while (newIndex === currentPhraseIndex.value);

          currentPhraseIndex.value = newIndex;
          loadingText.value = LOADING_PHRASES[newIndex];

        }, intervalTime);
      };

      // [NEW] Î°úÎî© Ïï†ÎãàÎ©îÏù¥ÏÖò Ï§ëÏßÄ Ìï®Ïàò
      const stopLoadingAnimation = () => {
        if (loadingInterval.value) {
          clearInterval(loadingInterval.value);
          loadingInterval.value = null;
        }
      };

      const loadData = (callback) => {
        isLoading.value = true;
        startLoadingAnimation(3000);

        // 1. User Data Promise (LOGGING ADDED)
        const userPromise = new Promise(resolve => {
          google.script.run.withSuccessHandler(res => {
            console.log('API Response [apiGetCurrentUser]:', res); // <- NEW LOG
            if (res && res.success) {
              currentUser.value = res.data.email ? res.data : { email: '', isAdmin: false };
            } else {
              currentUser.value = { email: '', isAdmin: false };
            }
            resolve();
          }).apiGetCurrentUser();
        });

        // 2. Restaurant Data Promise (LOGGING ADDED)
        const mainDataPromise = new Promise(resolve => {
          google.script.run.withSuccessHandler(res => {
            console.log('API Response [apiGetRestaurants]:', res); // <- NEW LOG
            if (res && res.success) {
              restaurants.value = res.data; resolve(true);
            }
            else {
              showAlert('ÏãùÎãπ Î¶¨Ïä§Ìä∏ Î°úÎìú Ïã§Ìå®: ' + (res?.message || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò'));
              resolve(false);
            }
          }).apiGetRestaurants();
        });

        // 3. Review Data Promise (LOGGING ADDED)
        const reviewDataPromise = new Promise(resolve => {
          google.script.run.withSuccessHandler(res => {
            console.log('API Response [apiGetAllReviews]:', res); // <- NEW LOG
            if (res && res.success) {
              allReviews.value = res.data.reviews;

              const userEmail = currentUser.value.email;
              const reviewedIds = new Set();
              if (userEmail) {
                res.data.reviews.forEach(review => {
                  if (String(review.user_email) === String(userEmail)) {
                    reviewedIds.add(review.restaurant_id);
                  }
                });
              }
              myReviewedRestaurantIds.value = reviewedIds;

              resolve(true);
            } else {
              resolve(false);
            }
          }).apiGetAllReviews();
        });

        // 4. Likes Data Promise (LOGGING ADDED)
        const likesPromise = new Promise(resolve => {
          google.script.run.withSuccessHandler(res => {
            console.log('API Response [apiGetUserLikes]:', res); // <- NEW LOG
            if (res && res.success) { userLikes.value = new Set(res.data); }
            resolve();
          }).apiGetUserLikes();
        });

        // 5. Menu Data Promise (LOGGING ADDED)
        const menuDataPromise = new Promise(resolve => {
          google.script.run.withSuccessHandler(res => {
            console.log('API Response [apiGetAllMenus]:', res); // <- NEW LOG
            if (res && res.success) {
              const map = {};
              res.data.forEach(m => {
                if (!map[m.restaurant_id]) map[m.restaurant_id] = [];
                map[m.restaurant_id].push(m);
              });
              menuMap.value = map; // [NEW] menuMapÏóê Ï∫êÏã±
            }
            resolve();
          }).apiGetAllMenus();
        });

        Promise.all([userPromise, mainDataPromise, reviewDataPromise, likesPromise, menuDataPromise]).then(([u, m, r, l]) => {
          stopLoadingAnimation();
          isLoading.value = false;

          if (m && r) {
            mergeReviewsToRestaurants();
            if (modalOpen.value && selectedRestaurant.value.id) {
              const updated = restaurants.value.find(r => r.id === selectedRestaurant.value.id);
              if (updated && (modalMode.value === 'view' || modalMode.value === 'readonly')) selectedRestaurant.value = updated;
            }
            if (callback && typeof callback === 'function') callback();
          }
        });
      };

      const mergeReviewsToRestaurants = () => {
        if (restaurants.value.length === 0) return;

        restaurants.value.forEach(rest => {
          const myReviews = allReviews.value.filter(r => String(r.restaurant_id) === String(rest.id));
          rest.review_count = myReviews.length;
          if (myReviews.length > 0) {
            // ÏµúÏã† Î¶¨Î∑∞Î•º Ï∞æÏùå (Ïù¥ÎØ∏ created_at Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨ÎêòÏñ¥ ÏûàÎã§Í≥† Í∞ÄÏ†ï)
            rest.latestReview = myReviews[0].comment;
            rest.latestReviewRate = myReviews[0].rate;
          } else {
            rest.latestReview = null;
            rest.latestReviewRate = null;
          }
        });
      };

      // [NEW] Like Logic
      const isLiked = (restId) => userLikes.value.has(restId);
      const toggleLikeFilter = () => showLikeFilter.value = !showLikeFilter.value;
      const toggleLike = (rest) => {
        if (!currentUser.value.email) { showAlert('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.'); return; }

        const wasLiked = userLikes.value.has(rest.id);
        if (wasLiked) {
          userLikes.value.delete(rest.id);
          rest.like_count = Math.max(0, (rest.like_count || 0) - 1);
        } else {
          userLikes.value.add(rest.id);
          rest.like_count = (rest.like_count || 0) + 1;
        }

        google.script.run.withSuccessHandler(res => {
          if (!res.success) {
            if (wasLiked) { userLikes.value.add(rest.id); rest.like_count++; }
            else { userLikes.value.delete(rest.id); rest.like_count--; }
            showAlert('Ï∞úÌïòÍ∏∞ Ïã§Ìå®', 'Ï≤òÎ¶¨ Ïã§Ìå®');
          }
        }).apiToggleLike(rest.id);
      };

      const addLikedToWheel = () => {
        const likedRests = restaurants.value.filter(r => userLikes.value.has(r.id));
        likedRests.forEach(t => addToWheel(t));
      };

      // Modal Methods

      const formatPrice = (price) => {
        if (price === null || price === undefined || price === '') return 'Í∞ÄÍ≤© Ï†ïÎ≥¥ ÏóÜÏùå';

        const numPrice = Number(price);
        if (isNaN(numPrice) || numPrice === 0) return 'Í∞ÄÍ≤© Ï†ïÎ≥¥ ÏóÜÏùå';

        // toLocaleStringÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Ï≤ú Îã®ÏúÑ Íµ¨Î∂Ñ Í∏∞Ìò∏ Ï∂îÍ∞Ä
        return `${numPrice.toLocaleString()}Ïõê`;
      };

      const addMenuInput = () => {
        // ÏÉà Î©îÎâ¥ Ìï≠Î™©ÏùÑ Ï∂îÍ∞ÄÌï©ÎãàÎã§. is_signatureÎäî Í∏∞Î≥∏Ï†ÅÏúºÎ°ú falseÎ°ú ÏÑ§Ï†ï
        // Îπà Í∞ùÏ≤¥Î°ú ÏãúÏûëÌïòÏó¨ VueÏùò restaurantForm.menus Î∞∞Ïó¥Ïóê Ï∂îÍ∞ÄÌï©ÎãàÎã§.
        restaurantForm.value.menus.push({ name: '', price: '', is_signature: false });
      };

      // Î©îÎâ¥ ÏÇ≠Ï†ú Ìï®Ïàò (ÎàÑÎùΩ Í∞ÄÎä•ÏÑ±Ïù¥ ÏûàÏñ¥ Ìï®Íªò Ï∂îÍ∞Ä Í∂åÏû•)
      const removeMenuInput = (index) => {
        // Î©îÎâ¥ Ìï≠Î™©ÏùÑ Ïù∏Îç±Ïä§Î•º ÌÜµÌï¥ ÏÇ≠Ï†úÌï©ÎãàÎã§.
        restaurantForm.value.menus.splice(index, 1);
      };

      const toggleMenuSignature = (index) => {
        // ÌäπÏ†ï Ïù∏Îç±Ïä§Ïùò is_signature Í∞íÏùÑ ÌÜ†Í∏ÄÌï©ÎãàÎã§.
        const menu = restaurantForm.value.menus[index];
        if (menu) {
          menu.is_signature = !menu.is_signature;
        }
      };

      const cleanNumber = (value) => {
        if (typeof value === 'string') {
          return value.replace(/[^0-9]/g, '');
        }
        return String(value);
      };

      const formatNumberWithCommas = (value) => {
        const cleaned = cleanNumber(value);
        if (!cleaned) return '';
        return Number(cleaned).toLocaleString('ko-KR');
      };

      const calculateAvgPrice = (menus) => {
        if (!menus || menus.length === 0) return 0; // [ÏàòÏ†ï] ÌÖçÏä§Ìä∏Í∞Ä ÏïÑÎãå 0 Î∞òÌôò

        const validPrices = menus
          .map(m => Number(m.price) || 0)
          .filter(p => p > 0);

        if (validPrices.length === 0) return 0;

        const sum = validPrices.reduce((total, price) => total + price, 0);
        const avg = Math.round(sum / validPrices.length);

        // [ÏàòÏ†ï] ÏàúÏàò ÌèâÍ∑† Ïà´ÏûêÎßå Î∞òÌôò
        return avg;
      };

      const openModal = (restId) => {
        modalMode.value = 'view';

        // 1. Ï†ÑÎã¨Î∞õÏùÄ IDÎ°ú restaurants Î∞∞Ïó¥ÏóêÏÑú ÏãùÎãπ Í∞ùÏ≤¥Î•º Ï∞æÏäµÎãàÎã§.
        const rest = restaurants.value.find(r => r.id === restId);

        if (!rest) {
          showAlert('ÏãùÎãπ Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
          return;
        }

        selectedRestaurant.value = rest;

        // [NEW] Î©îÎâ¥ Îç∞Ïù¥ÌÑ∞ Ï£ºÏûÖ Î∞è Ï†ïÎ†¨
        const cachedMenus = menuMap.value[rest.id] || [];
        cachedMenus.sort((a, b) => (b.is_signature === true) - (a.is_signature === true));
        selectedRestaurant.value.menus = cachedMenus;

        reviewForm.value = { rate: 0, user_name: '', comment: '', restaurant_id: rest.id };
        modalOpen.value = true;
        updateCurrentModalReviews(rest.id);
        showKebabMenu.value = false;
      };
      const openReadOnlyModal = (restId) => { // [ÏàòÏ†ï] ÏãùÎãπ ID(restId)Î•º ÏßÅÏ†ë Ïù∏ÏûêÎ°ú Î∞õÎèÑÎ°ù Î≥ÄÍ≤Ω
        modalMode.value = 'readonly';

        const rest = restaurants.value.find(r => r.id === restId);

        if (!rest) {
          showAlert('ÏãùÎãπ Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
          return;
        }

        selectedRestaurant.value = rest;

        // [NEW] Î©îÎâ¥ Îç∞Ïù¥ÌÑ∞ Ï£ºÏûÖ Î∞è Ï†ïÎ†¨
        const cachedMenus = menuMap.value[rest.id] || [];
        cachedMenus.sort((a, b) => (b.is_signature === true) - (a.is_signature === true));
        selectedRestaurant.value.menus = cachedMenus;

        reviewForm.value = { rate: 0, user_name: '', comment: '', restaurant_id: rest.id };
        modalOpen.value = true;
        updateCurrentModalReviews(rest.id);
        showKebabMenu.value = false;
      };

      const openAddRestaurantModal = () => {
        modalMode.value = 'create';
        restaurantForm.value = {
          id: '', name: '', category: '', tags: [], signature_menu: '', price: '', tagInput: '',
          menus: [{ name: '', price: '', is_signature: false }]
        };
        duplicateList.value = [];
        modalOpen.value = true;
        showKebabMenu.value = false;
      };

      const startEditRestaurant = () => {
        modalMode.value = 'edit';
        const r = selectedRestaurant.value;
        const cachedMenus = menuMap.value[r.id] || [];

        restaurantForm.value = {
          id: r.id, name: r.name, category: r.category, tags: [...r.tags], signature_menu: r.signature_menu, price: r.price, tagInput: '',
          menus: cachedMenus.map(m => ({ name: m.name, price: m.price, is_signature: m.is_signature || false }))
        };

        duplicateList.value = [];
        showKebabMenu.value = false;
      };

      const closeModal = () => {
        if (isSubmitting.value) return;
        modalOpen.value = false;
        cancelEditReview();
        showCategoryDropdown.value = false;
        showKebabMenu.value = false;
      };
      const handleCancel = () => {
        if (isSubmitting.value) return;
        if (modalMode.value === 'edit') {
          modalMode.value = 'view';
          duplicateList.value = [];
        } else {
          closeModal();
        }
      };
      const openUserModal = () => { showUserModal.value = true; };
      const closeUserModal = () => { showUserModal.value = false; };

      const formatReviewComment = (comment) => {
        if (!comment) return '';
        let formatted = comment;
        const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
        formatted = formatted.replace(urlRegex, url => '<a href="' + url + '" target="_blank" class="text-blue-500 hover:text-blue-700 hover:underline">' + url + '</a>');
        return formatted.replace(/\n/g, '<br>');
      };

      const processTagInput = (e) => {
        if (isComposing.value || !restaurantForm.value.tagInput.trim()) return;
        if (e.key === 'Enter' || e.key === ' ' || e.key === ',') {
          e.preventDefault();
          const val = restaurantForm.value.tagInput.trim();
          if (val && !restaurantForm.value.tags.includes(val)) restaurantForm.value.tags.push(val);
          restaurantForm.value.tagInput = '';
        }
      };
      const handleCompositionStart = () => { isComposing.value = true; };
      const handleCompositionEnd = () => { isComposing.value = false; };
      const removeTag = (index) => { restaurantForm.value.tags.splice(index, 1); };
      const openCategoryDropdown = () => { showCategoryDropdown.value = true; focusedCategoryIndex.value = -1; };
      const closeCategoryDropdown = () => { setTimeout(() => { showCategoryDropdown.value = false; focusedCategoryIndex.value = -1; }, 200); };
      const selectCategory = (cat) => { restaurantForm.value.category = cat; showCategoryDropdown.value = false; };
      const onCategoryKeydown = (e) => { if (!showCategoryDropdown.value) { if (e.key === 'ArrowDown') openCategoryDropdown(); return; } const options = filteredCategoryOptions.value; if (e.key === 'ArrowDown') { e.preventDefault(); if (focusedCategoryIndex.value < options.length - 1) focusedCategoryIndex.value++; } else if (e.key === 'ArrowUp') { e.preventDefault(); if (focusedCategoryIndex.value > 0) focusedCategoryIndex.value--; } else if (e.key === 'Enter') { e.preventDefault(); if (focusedCategoryIndex.value >= 0 && focusedCategoryIndex.value < options.length) { selectCategory(options[focusedCategoryIndex.value]); } else if (options.length === 1) { selectCategory(options[0]); } else { showCategoryDropdown.value = false; } } else if (e.key === 'Escape') { showCategoryDropdown.value = false; } };

      watch(() => restaurantForm.value.name, (newName) => {
        if (!newName || (modalMode.value !== 'create' && modalMode.value !== 'edit')) { duplicateList.value = []; return; }
        const normalizedInput = newName.replace(/\s/g, '').toLowerCase();
        const duplicates = restaurants.value.filter(r => {
          if (modalMode.value === 'edit' && r.id === restaurantForm.value.id) return false;
          const normalizedTarget = r.name.replace(/\s/g, '').toLowerCase();
          return normalizedTarget.includes(normalizedInput);
        });
        duplicateList.value = duplicates;
      });

      const saveRestaurant = async () => {
        if (!restaurantForm.value.name) { showAlert('ÏÉÅÌò∏Î™ÖÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.'); return; }
        if (!restaurantForm.value.category) { showAlert('Ïπ¥ÌÖåÍ≥†Î¶¨Î•º ÏûÖÎ†•ÌïòÍ±∞ÎÇò ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.'); return; }
        if (duplicateList.value.length > 0) {
          const confirmSave = await showConfirm(`Ïú†ÏÇ¨Ìïú ÏÉÅÌò∏Î™ÖÏù¥ ${duplicateList.value.length}Í∞ú Ï°¥Ïû¨Ìï©ÎãàÎã§.\nÍ∑∏ÎûòÎèÑ Ï†ÄÏû•ÌïòÏãúÍ≤†ÏäµÎãàÍπå?`);
          if (!confirmSave) return;
        }

        isSubmitting.value = true;
        const isEdit = modalMode.value === 'edit';
        const apiFunc = !isEdit ? 'apiAddRestaurant' : 'apiUpdateRestaurant';

        console.log('DEBUG PAYLOAD [originMenus]:', restaurantForm.value.menus);

        const cleanMenus = restaurantForm.value.menus
          .filter(m => m.name && m.name.trim() !== '')
          .map(m => ({
            name: m.name.trim(),
            price: Number(m.price) || 0,
            is_signature: m.is_signature || false
          }));
        console.log('DEBUG PAYLOAD [cleanMenus]:', cleanMenus);

        const payload = { ...restaurantForm.value, menus: cleanMenus };

        if (Object.prototype.hasOwnProperty.call(payload, 'signature_menu')) {
          delete payload.signature_menu;
        }

        console.log('DEBUG PAYLOAD [Full]:', payload);

        // ÏÑúÎ≤Ñ ÏöîÏ≤≠
        google.script.run.withSuccessHandler(res => {
          if (res.success && res.data) {

            // [NEW] menuMap Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
            const updatedMenus = cleanMenus.map(m => ({
              restaurant_id: String(res.data.id),
              name: m.name, price: m.price, is_signature: m.is_signature
            }));
            menuMap.value[String(res.data.id)] = updatedMenus; // Ï∫êÏãú Ï†ÄÏû•

            // [NEW] Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
            updateRestaurantLocalState(res.data, isEdit);

            isSubmitting.value = false;

            if (isEdit) {
              modalMode.value = 'view';
            } else {
              modalMode.value = 'view';
              reviewForm.value = { rate: 0, user_name: '', comment: '', restaurant_id: selectedRestaurant.value.id };
              updateCurrentModalReviews(selectedRestaurant.value.id);
            }
          } else {
            isSubmitting.value = false;
            showAlert('ÏãùÎãπ Ï†ïÎ≥¥ Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.', 'Ï≤òÎ¶¨ Ïã§Ìå®');
          }
        })[apiFunc](payload); // [ÏàòÏ†ï] payload ÏÇ¨Ïö©
      };

      const deleteRestaurant = async () => {
        const confirmed = await showConfirm('Ï†ïÎßê Ïù¥ ÏãùÎãπ Ï†ïÎ≥¥Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?');
        if (!confirmed) return;

        isSubmitting.value = true;
        const idToDelete = modalMode.value === 'edit' ? restaurantForm.value.id : selectedRestaurant.value.id;

        google.script.run.withSuccessHandler(res => {
          if (res.success) {

            const index = restaurants.value.findIndex(r => r.id === idToDelete);
            if (index !== -1) {
              restaurants.value.splice(index, 1);
            }
            // [NEW] Î©îÎâ¥ Ï∫êÏãúÏóêÏÑúÎèÑ ÏÇ≠Ï†ú
            delete menuMap.value[idToDelete];

            isSubmitting.value = false;
            closeModal();
          } else {
            isSubmitting.value = false;
            showAlert('ÏãùÎãπ ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.', 'Ï≤òÎ¶¨ Ïã§Ìå®');
          }
        }).apiDeleteRestaurant(idToDelete);
      };

      const updateCurrentModalReviews = (restId) => {
        try {
          let filtered = allReviews.value.filter(r => String(r.restaurant_id) === String(restId));
          filtered.sort((a, b) => {
            const timeA = a.created_at ? new Date(a.created_at).getTime() : 0;
            const timeB = b.created_at ? new Date(b.created_at).getTime() : 0;
            if (timeA !== timeB) return timeB - timeA;
            const idA = String(a.id || ''), idB = String(b.id || '');
            return idB.localeCompare(idA, undefined, { numeric: true });
          });
          reviews.value = filtered;
        } catch (e) {
          reviews.value = allReviews.value.filter(r => String(r.restaurant_id) === String(restId));
        }
      };

      const submitReview = async () => {
        if (!reviewForm.value.rate || reviewForm.value.rate < 1) { showAlert('Î≥ÑÏ†êÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.'); return; }
        if (!reviewForm.value.user_name) { showAlert('ÏûëÏÑ±ÏûêÎ•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.'); return; }
        if (!reviewForm.value.comment) { showAlert('ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.'); return; }
        isSubmitting.value = true;

        google.script.run.withSuccessHandler(res => {
          if (res.success && res.data) {
            const newReviewData = {
              id: res.data.id,
              restaurant_id: selectedRestaurant.value.id,
              rate: reviewForm.value.rate,
              comment: reviewForm.value.comment,
              user_name: reviewForm.value.user_name,
              user_email: currentUser.value.email,
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString(),
            };

            updateReviewAndRestaurantState(selectedRestaurant.value.id, newReviewData);

            reviewForm.value = { rate: 0, user_name: '', comment: '', restaurant_id: selectedRestaurant.value.id };
            highlightReviewId.value = newReviewData.id;
            setTimeout(() => { highlightReviewId.value = null; }, 2000);
            isSubmitting.value = false;

          } else {
            isSubmitting.value = false;
            showAlert('Î¶¨Î∑∞ Îì±Î°ùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.', 'Ï≤òÎ¶¨ Ïã§Ìå®');
          }
        }).apiAddReview(reviewForm.value);
      };

      const deleteReview = async (reviewId) => {
        const confirmed = await showConfirm('Ï†ïÎßê Ïù¥ Î¶¨Î∑∞Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?');
        if (!confirmed) return;
        isSubmitting.value = true;

        google.script.run.withSuccessHandler(res => {
          if (res.success) {
            updateReviewAndRestaurantState(selectedRestaurant.value.id, null, reviewId);

            isSubmitting.value = false;
          } else {
            isSubmitting.value = false;
            showAlert('Î¶¨Î∑∞ ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.', 'Ï≤òÎ¶¨ Ïã§Ìå®');
          }
        }).apiDeleteReview(reviewId);
      };

      const startEditReview = (review) => { editingReviewId.value = review.id; editForm.value = { id: review.id, rate: review.rate, comment: review.comment }; };
      const cancelEditReview = () => { editingReviewId.value = null; editForm.value = { id: '', rate: 0, comment: '' }; };
      const saveEditReview = async () => {
        if (!editForm.value.comment) { showAlert('ÏΩîÎ©òÌä∏Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.'); return; }
        isReviewSubmitting.value = true;

        google.script.run.withSuccessHandler(res => {
          if (res.success) {
            const editedReview = {
              id: editForm.value.id,
              restaurant_id: selectedRestaurant.value.id,
              rate: editForm.value.rate,
              comment: editForm.value.comment,
              user_name: reviews.value.find(r => r.id === editForm.value.id)?.user_name || '',
              user_email: currentUser.value.email,
              created_at: reviews.value.find(r => r.id === editForm.value.id)?.created_at || new Date().toISOString(),
              updated_at: new Date().toISOString(),
            };

            updateReviewAndRestaurantState(selectedRestaurant.value.id, editedReview);

            cancelEditReview();
            highlightReviewId.value = editedReview.id;
            setTimeout(() => { highlightReviewId.value = null; }, 2000);
            isReviewSubmitting.value = false;

          } else {
            isReviewSubmitting.value = false;
            showAlert('Î¶¨Î∑∞ ÏàòÏ†ïÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.', 'Ï≤òÎ¶¨ Ïã§Ìå®');
          }
        }).apiUpdateReview(editForm.value);
      };

      const canManageReview = (review) => { if (currentUser.value.isAdmin) return true; if (currentUser.value.email && String(review.user_email) === String(currentUser.value.email)) return true; return false; };

      const updateTooltip = (e, rest) => {
        if (windowWidth.value < 768) return;
        let x = e.clientX + 10; let y = e.clientY + 10;
        if (x + 250 > window.innerWidth) x = e.clientX - 250;
        if (y + 150 > window.innerHeight) y = e.clientY - 150;
        tooltipData.value = rest; tooltipVisible.value = true; tooltipPos.value = { x: x, y: y };
      };
      const hideTooltip = () => tooltipVisible.value = false;
      const toggleFilter = () => isFilterOpen.value = !isFilterOpen.value;
      const toggleFilterItem = (type, value) => { const idx = filters.value[type].indexOf(value); if (idx === -1) filters.value[type].push(value); else filters.value[type].splice(idx, 1); currentPage.value = 1; };

      // [NEW] Ìà¥ÌåÅÏö©: Î©îÎâ¥Î•º Ï†ïÎ†¨ÌïòÍ≥† Ìè¨Îß∑ÌïòÏó¨ Î¨∏ÏûêÏó¥Î°ú Î∞òÌôò (ÏãúÍ∑∏ÎãàÏ≤ò Ïö∞ÏÑ†, ÏµúÎåÄ 3Í∞ú)
      const getFormattedMenuString = (menus) => {
        if (!menus || menus.length === 0) return 'Î©îÎâ¥ Ï†ïÎ≥¥ ÏóÜÏùå';

        // ÏãúÍ∑∏ÎãàÏ≤ò Ïö∞ÏÑ† Ï†ïÎ†¨ (b.is_signature - a.is_signature)
        const sorted = [...menus].sort((a, b) => (b.is_signature - a.is_signature));

        // ÏÉÅÏúÑ 3Í∞ú Î©îÎâ¥Î•º "Î©îÎâ¥Î™Ö (Í∞ÄÍ≤©)" ÌòïÏãùÏúºÎ°ú Ìè¨Îß∑
        return sorted.slice(0, 3)
          .map(m => `${m.name} (${formatPrice(m.price)})`)
          .join(', ');
      };

      const setSort = (field) => {
        if (sort.value.field === field) {
          if (sort.value.order === 'desc') sort.value.order = 'asc';
          else if (sort.value.order === 'asc') sort.value.order = null;
          else sort.value.order = 'desc';
        } else {
          sort.value.field = field; sort.value.order = 'desc';
        }
      };
      const setSortOrder = () => {
        if (!sort.value.field || sort.value.order === null) { sort.value.field = 'name'; sort.value.order = 'desc'; }
        else if (sort.value.order === 'desc') { sort.value.order = 'asc'; }
        else { sort.value.order = 'desc'; }
      };
      const getSortIcon = (field) => {
        if (sort.value.field !== field || !sort.value.order) return 'ph ph-arrows-down-up text-gray-400';
        return sort.value.order === 'desc' ? 'ph ph-caret-down' : 'ph ph-caret-up';
      };

      const toggleSortDropdown = () => {
        sortDropdownOpen.value = !sortDropdownOpen.value;
      };
      const togglePageSizeDropdown = () => {
        pageSizeDropdownOpen.value = !pageSizeDropdownOpen.value;
      };

      const addCategoryToWheel = (val) => {
        let toAdd = [];
        if (val === 'Î∞ñÎ∞•Ìåå') {
          toAdd = restaurants.value.filter(rest => {
            const isDelivery = (rest.category && rest.category === 'Î∞∞Îã¨') || (rest.tags && rest.tags.some(t => t.includes('Î∞∞Îã¨')));
            return !isDelivery;
          });
        } else {
          toAdd = restaurants.value.filter(r => r.category === val || (r.tags && r.tags.includes(val)));
        }
        toAdd.forEach(t => addToWheel(t));
      };
      const addAllToWheel = () => restaurants.value.forEach(t => addToWheel(t));
      const addToWheel = (item) => { if (!wheelItems.value.find(w => w.id === item.id)) { wheelItems.value.push(item); wheelSearch.value = ''; drawWheel(); } };
      const removeFromWheel = (index) => { wheelItems.value.splice(index, 1); drawWheel(); };
      const clearWheel = () => { wheelItems.value = []; drawWheel(); };
      const resetWheel = () => { winner.value = null; wheelRotation = 0; pinAngle = 0; drawWheel(); };

      const drawWheel = () => {
        const canvas = document.getElementById('wheelCanvas'); if (!canvas) return; const ctx = canvas.getContext('2d');
        const width = canvas.width, height = canvas.height; const verticalOffset = 20; const radius = width / 2 - 30; const centerX = width / 2, centerY = height / 2 + verticalOffset;
        ctx.clearRect(0, 0, width, height);
        if (wheelItems.value.length === 0) { ctx.fillStyle = '#f3f4f6'; ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI); ctx.fill(); ctx.fillStyle = '#9ca3af'; ctx.font = '20px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('ÌõÑÎ≥¥ Î¶¨Ïä§Ìä∏Î•º Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî', centerX, centerY); return; }
        const step = (2 * Math.PI) / wheelItems.value.length; const colors = ['#fca5a5', '#fdba74', '#fcd34d', '#86efac', '#93c5fd', '#c4b5fd', '#f9a8d4'];
        ctx.save(); ctx.translate(centerX, centerY); ctx.rotate(wheelRotation);
        for (let i = 0; i < wheelItems.value.length; i++) {
          const angle = i * step;
          ctx.beginPath(); ctx.moveTo(0, 0); ctx.arc(0, 0, radius, angle, angle + step); ctx.fillStyle = colors[i % colors.length]; ctx.fill(); ctx.stroke();
          ctx.save(); ctx.rotate(angle); ctx.beginPath(); ctx.arc(radius, 0, 3, 0, 2 * Math.PI); ctx.fillStyle = 'white'; ctx.fill(); ctx.strokeStyle = '#d1d5db'; ctx.stroke(); ctx.restore();
          ctx.save(); ctx.rotate(angle + step / 2); ctx.textAlign = 'right'; ctx.fillStyle = '#374151'; ctx.font = 'bold 14px sans-serif'; ctx.fillText(wheelItems.value[i].name, radius - 20, 5); ctx.restore();
        }
        ctx.restore();
        ctx.beginPath(); ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI); ctx.fillStyle = '#6b7280'; ctx.fill();
        ctx.save(); ctx.translate(centerX, 5 + verticalOffset); ctx.rotate(pinAngle); ctx.beginPath(); ctx.arc(0, 0, 8, Math.PI, 0); ctx.lineTo(0, 30); ctx.lineTo(-8, 0); ctx.closePath(); ctx.fillStyle = '#dc2626'; ctx.fill(); ctx.strokeStyle = '#991b1b'; ctx.lineWidth = 1; ctx.stroke(); ctx.beginPath(); ctx.arc(0, 0, 3, 0, 2 * Math.PI); ctx.fillStyle = '#fca5a5'; ctx.fill(); ctx.restore();
      };

      const spinWheel = () => {
        if (isSpinning.value || wheelItems.value.length === 0) return;
        isSpinning.value = true; winner.value = null; wheelVelocity = 0.4 + Math.random() * 0.1;
        const segAngle = (2 * Math.PI) / wheelItems.value.length; const pointerAngle = 1.5 * Math.PI; prevIndex = 0;
        const animate = () => {
          wheelVelocity *= 0.99; wheelRotation += wheelVelocity;
          const normalizedRot = wheelRotation % (2 * Math.PI);
          const currentRelativeAngle = (pointerAngle - normalizedRot + (2 * Math.PI)) % (2 * Math.PI);
          const currentIndex = Math.floor(currentRelativeAngle / segAngle);
          if (currentIndex !== prevIndex) { pinVelocity -= pinKick; }
          prevIndex = currentIndex;
          pinVelocity += (0 - pinAngle) * pinSpring; pinVelocity *= pinDamping; pinAngle += pinVelocity;
          pinAngle = Math.max(-Math.PI / 18, Math.min(Math.PI / 3, pinAngle));
          drawWheel();
          if (wheelVelocity < 0.002) { isSpinning.value = false; cancelAnimationFrame(animationId); calculateWinner(); pinAngle = 0; drawWheel(); } else { animationId = requestAnimationFrame(animate); }
        };
        animate();
      };
      const calculateWinner = () => { const normRot = wheelRotation % (2 * Math.PI); const segAngle = (2 * Math.PI) / wheelItems.value.length; let ptrAngle = (1.5 * Math.PI) - normRot; if (ptrAngle < 0) ptrAngle += 2 * Math.PI; winner.value = wheelItems.value[Math.floor(ptrAngle / segAngle) % wheelItems.value.length]; };

      const formatDate = (dateStr) => { if (!dateStr) return ''; const d = new Date(dateStr); return `${d.getFullYear()}.${d.getMonth() + 1}.${d.getDate()}`; };
      const updateWidth = () => windowWidth.value = window.innerWidth;

      const toggleKebabMenu = () => {
        showKebabMenu.value = !showKebabMenu.value;
      };

      const handleMenuPriceInput = (menuItem, newFormattedValue) => {
        const cleanedValue = cleanNumber(newFormattedValue);
        menuItem.price = parseInt(cleanedValue) || 0;
      };

      const formatDateTime = (dateStr) => {
        if (!dateStr) return '';
        try {
          const d = new Date(dateStr);
          const datePart = `${d.getFullYear()}-${(d.getMonth() + 1).toString().padStart(2, '0')}-${d.getDate().toString().padStart(2, '0')}`;
          const timePart = `${d.getHours().toString().padStart(2, '0')}:${d.getMinutes().toString().padStart(2, '0')}:${d.getSeconds().toString().padStart(2, '0')}`;
          return `${datePart} ${timePart}`;
        } catch (e) {
          return 'ÎÇ†Ïßú Ïò§Î•ò';
        }
      };

      // --- Watchers ---
      watch(isLoading, (newVal, oldVal) => {
        if (oldVal === true && newVal === false) {
          nextTick(() => {
            if (windowWidth.value >= 768) {
              isFilterOpen.value = true;
            }
          });
        }
      });

      onMounted(() => {
        loadData();
        window.addEventListener('resize', updateWidth);
        watch(currentTab, (newVal) => { if (newVal === 'wheel') nextTick(() => drawWheel()); });

        window.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            if (isSubmitting.value) return;

            if (showKebabMenu.value) {
              showKebabMenu.value = false;
              return;
            }

            if (sortDropdownOpen.value) { sortDropdownOpen.value = false; return; }
            if (pageSizeDropdownOpen.value) { pageSizeDropdownOpen.value = false; return; }

            if (alertState.value.visible) onAlertCancel();

            else if (showUserModal.value) closeUserModal();

            else if (modalOpen.value) {
              if (modalMode.value === 'view' || modalMode.value === 'readonly') closeModal();
            }
          }
        });

        watch(modalOpen, (val) => {
          document.body.style.overflow = val ? 'hidden' : 'auto';
          showKebabMenu.value = false;
        });

        watchEffect(() => {
          restaurantForm.value.price = calculatedPriceDisplay.value;
        });

        document.addEventListener('click', (e) => {
          const button = kebabButton.value;
          if (showKebabMenu.value && button && !button.contains(e.target)) {
            let target = e.target;
            let isKebabMenuClicked = false;
            while (target) {
              if (target.classList && target.classList.contains('kebab-dropdown')) {
                isKebabMenuClicked = true;
                break;
              }
              target = target.parentNode;
            }
            if (!isKebabMenuClicked) {
              showKebabMenu.value = false;
            }
          }

          if (sortDropdownOpen.value) {
            if (!e.target.closest('.js-sort-dropdown')) {
              sortDropdownOpen.value = false;
            }
          }

          if (pageSizeDropdownOpen.value) {
            if (!e.target.closest('.js-pagesize-dropdown')) {
              pageSizeDropdownOpen.value = false;
            }
          }
        });
      });

      return {
        restaurants, currentTab, pageSize, currentPage, isLoading, currentUser, userInitial, userId, userReviewCount, userRankInfo,
        isFilterOpen, filters, toggleFilter, toggleFilterItem, uniqueCategories, uniqueTags,
        filteredRestaurants, paginatedRestaurants, totalPages, sort, setSort, setSortOrder, getSortIcon,
        modalOpen, modalMode, selectedRestaurant, restaurantForm, duplicateList, isNewCategory, filteredCategoryOptions, showCategoryDropdown, focusedCategoryIndex,
        openModal, openReadOnlyModal, openAddRestaurantModal, startEditRestaurant, closeModal, processTagInput, handleCompositionStart, handleCompositionEnd, isComposing, removeTag, saveRestaurant, deleteRestaurant,
        openCategoryDropdown, closeCategoryDropdown, selectCategory, onCategoryKeydown,
        reviews, reviewForm, isSubmitting, submitReview, deleteReview, canManageReview, startEditReview, cancelEditReview, saveEditReview, highlightReviewId, editingReviewId, editForm, isReviewSubmitting, hoverRate, formatDate,
        wheelItems, wheelSearch, addToWheel, removeFromWheel, spinWheel, isSpinning, winner, addCategoryToWheel, addAllToWheel, clearWheel, filteredWheelCandidates, resetWheel, isWheelListExpanded,
        tooltipVisible, tooltipData, tooltipPos, updateTooltip, hideTooltip, alertState, onAlertConfirm, onAlertCancel, windowWidth, menuMap,
        showUserModal, openUserModal, closeUserModal, searchQuery,
        GOOGLE_SHEET_URL, BASE_WEBAPP_URL, handleCancel, formatReviewComment,
        userLikes, isLiked, toggleLike, showLikeFilter, toggleLikeFilter,
        showMyReviewsFilter, showPendingReviewsFilter,
        addLikedToWheel,
        myReviewedRestaurantIds,
        showKebabMenu,
        toggleKebabMenu,
        kebabButton,
        sortDropdownOpen, pageSizeDropdownOpen, toggleSortDropdown, togglePageSizeDropdown,
        toggleMenuSignature, formatPrice, addMenuInput, removeMenuInput, sortedMenus, handleMenuPriceInput, formatNumberWithCommas, calculatedPriceDisplay,
        getFormattedMenuString,
        myPageTab, myLikedRestaurants, myReviews, formatDateTime, isMobile, loadingText
      };
    }
  }).mount('#app');
</script>