<script>
  const { createApp, ref, computed, onMounted, onUnmounted, watch, watchEffect, nextTick } = Vue;

  createApp({
    setup() {
      // Vue 3 Composition API에서는 DOM 참조를 위해 ref를 사용합니다.
      const kebabButton = ref(null); // [NEW] 케밥 버튼 DOM 요소 참조용

      // --- Constants ---
      const GOOGLE_SHEET_URL = 'https://docs.google.com/spreadsheets/d/1Zs610z6VE5AxeaJblNM8zRDu8fbGgn82F3nR7OId3ok/';
      const appElement = document.getElementById('app');
      const BASE_WEBAPP_URL = appElement ? appElement.dataset.appUrl : '';

      // --- State ---
      const restaurants = ref([]);
      const allReviews = ref([]);
      const currentTab = ref('list');
      const pageSize = ref(30);
      const currentPage = ref(1);

      const windowWidth = ref(window.innerWidth);
      const currentUser = ref({ email: '', isAdmin: false });
      const isLoading = ref(true);

      const showUserModal = ref(false);

      const isFilterOpen = ref(false); // 초기 상태는 접힘
      const filters = ref({ categories: [], tags: [], minRate: 0, maxPrice: 0 });
      // [NEW] 필터 상태
      const showLikeFilter = ref(false);
      const showMyReviewsFilter = ref(false);
      const showPendingReviewsFilter = ref(false);
      const searchQuery = ref('');

      const sort = ref({ field: 'name', order: 'asc' });

      // [추가] 모바일/데스크탑 드롭다운 제어 상태
      const sortDropdownOpen = ref(false);
      const pageSizeDropdownOpen = ref(false);

      // [NEW] User Likes State
      const userLikes = ref(new Set());

      // [NEW] 성능 개선을 위한 캐싱 상태
      const myReviewedRestaurantIds = ref(new Set());
      const menuMap = ref({}); // [NEW] 메뉴 캐싱 상태 추가

      // --- Modal & Restaurant CRUD State ---
      const modalOpen = ref(false);
      const modalMode = ref('view');
      const selectedRestaurant = ref({});

      // [수정] restaurantForm에 menus 배열과 is_signature 관련 필드 추가
      const restaurantForm = ref({ id: '', name: '', category: '', tags: [], signature_menu: '', price: '', tagInput: '', menus: [] });

      const duplicateList = ref([]);

      const showCategoryDropdown = ref(false);
      const focusedCategoryIndex = ref(-1);

      // Reviews State
      const reviews = ref([]);
      const isSubmitting = ref(false);
      const highlightReviewId = ref(null);
      const reviewForm = ref({ rate: 0, user_name: '', comment: '' });
      const hoverRate = ref(0);
      const editingReviewId = ref(null);
      const editForm = ref({ id: '', rate: 0, comment: '' });
      const isReviewSubmitting = ref(false);

      const alertState = ref({ visible: false, type: 'alert', title: '', message: '', resolve: null });

      // [NEW] 케밥 메뉴 상태
      const showKebabMenu = ref(false);

      // Tooltip & Wheel State
      const tooltipVisible = ref(false);
      const tooltipData = ref({});
      const tooltipPos = ref({ x: 0, y: 0 });
      const wheelItems = ref([]);
      const wheelSearch = ref('');
      const isSpinning = ref(false);
      const winner = ref(null);
      const isWheelListExpanded = ref(true);
      const isComposing = ref(false);

      const myPageTab = ref('info');

      let wheelRotation = 0;
      let wheelVelocity = 0;
      let animationId = null;
      let prevIndex = 0;
      let pinAngle = 0;
      let pinVelocity = 0;
      let pinSpring = 0.2;
      let pinDamping = 0.94;
      let pinKick = 0.15;
      let pinDrag = 0.8;

      // --- Computed ---
      const uniqueCategories = computed(() => {
        const cats = new Set(restaurants.value.map(r => r.category));
        return Array.from(cats).sort();
      });
      const uniqueTags = computed(() => {
        const tags = new Set();
        restaurants.value.forEach(r => r.tags.forEach(t => tags.add(t)));
        return Array.from(tags).sort();
      });

      const isNewCategory = computed(() => {
        const cat = restaurantForm.value.category;
        return cat && !uniqueCategories.value.includes(cat);
      });

      const filteredCategoryOptions = computed(() => {
        const input = (restaurantForm.value.category || '').replace(/\s/g, '').toLowerCase();
        if (!input) return uniqueCategories.value;
        return uniqueCategories.value.filter(cat => cat.replace(/\s/g, '').toLowerCase().includes(input));
      });

      const filteredRestaurants = computed(() => {
        let result = restaurants.value.filter(r => {
          if (Number(r.rate) < filters.value.minRate) return false;
          if (filters.value.categories.length > 0 && !filters.value.categories.includes(r.category)) return false;
          if (filters.value.tags.length > 0 && !r.tags.some(t => filters.value.tags.includes(t))) return false;

          const priceValue = Number(r.price || 0); // r.price가 숫자라고 가정
          if (filters.value.maxPrice > 0 && priceValue > 0 && priceValue > filters.value.maxPrice) {
            return false;
          }

          // [NEW] 좋아요 필터 적용
          if (showLikeFilter.value) {
            if (!userLikes.value.has(r.id)) return false;
          }

          // [NEW] 내가 리뷰 남긴 식당 필터 (캐싱된 Set 사용)
          if (showMyReviewsFilter.value) {
            if (!myReviewedRestaurantIds.value.has(r.id)) return false;
          }

          // [NEW] 내 리뷰를 기다리는 식당 필터 (내가 리뷰 남기지 않은 식당)
          if (showPendingReviewsFilter.value) {
            if (myReviewedRestaurantIds.value.has(r.id)) return false;
          }

          if (searchQuery.value) {
            const query = searchQuery.value.replace(/\s/g, '').toLowerCase();
            const targetName = r.name.replace(/\s/g, '').toLowerCase();
            if (!targetName.includes(query)) return false;
          }

          return true;
        });

        if (sort.value.order) {
          result.sort((a, b) => {
            let valA = a[sort.value.field];
            let valB = b[sort.value.field];
            if (typeof valA === 'string') valA = valA.toLowerCase();
            if (typeof valB === 'string') valB = valB.toLowerCase();

            if (sort.value.field === 'rate') {
              valA = Number(a.rate || 0); valB = Number(b.rate || 0);
            } else if (sort.value.field === 'reviewCount') {
              valA = Number(a.reviewCount || 0); valB = Number(b.reviewCount || 0);
            } else if (sort.value.field === 'like_count') {
              valA = Number(a.like_count || 0); valB = Number(b.like_count || 0);
            } else if (sort.value.field === 'price') { // [NEW] 가격순 정렬 (숫자 비교)
              valA = Number(a.price || 0); valB = Number(b.price || 0);
            }

            if (valA < valB) return sort.value.order === 'asc' ? -1 : 1;
            if (valA > valB) return sort.value.order === 'asc' ? 1 : -1;
            return 0;
          });
        }
        return result;
      });
      const totalPages = computed(() => Math.ceil(filteredRestaurants.value.length / pageSize.value));
      const paginatedRestaurants = computed(() => {
        const start = (currentPage.value - 1) * pageSize.value;
        const end = start + pageSize.value;
        return filteredRestaurants.value.slice(start, end);
      });
      const filteredWheelCandidates = computed(() => {
        if (!wheelSearch.value) return [];
        const term = wheelSearch.value.replace(/\s/g, '').toLowerCase();
        return restaurants.value.filter(r => r.name.replace(/\s/g, '').toLowerCase().includes(term));
      });

      const userId = computed(() => {
        if (!currentUser.value.email) return '';
        const atIndex = currentUser.value.email.indexOf('@');
        return atIndex > 0 ? currentUser.value.email.substring(0, atIndex) : currentUser.value.email;
      });

      const userInitial = computed(() => {
        return (currentUser.value && currentUser.value.email) ? currentUser.value.email.charAt(0).toUpperCase() : '?';
      });

      const userReviewCount = computed(() => {
        if (!currentUser.value.email || allReviews.value.length === 0) return 0;
        return allReviews.value.filter(review => String(review.user_email) === String(currentUser.value.email)).length;
      });

      const userRankInfo = computed(() => {
        if (isLoading.value) return null;
        const count = userReviewCount.value;

        // 1. 랭크 티어 정의 (기존 기준 유지)
        const RANK_TIERS = [
          { name: '아이언', min: 0, max: 0, nextMin: 1, icon: 'ph ph-crown-simple', color: 'text-gray-500' },
          { name: '브론즈', min: 1, max: 9, nextMin: 10, icon: 'ph-fill ph-crown-simple', color: 'text-amber-700' },
          { name: '실버', min: 10, max: 29, nextMin: 30, icon: 'ph-fill ph-crown-simple', color: 'text-gray-400' },
          { name: '골드', min: 30, max: 49, nextMin: 50, icon: 'ph-fill ph-crown-simple', color: 'text-yellow-500' },
          { name: '플래티넘', min: 50, max: 69, nextMin: 70, icon: 'ph-fill ph-crown', color: 'text-sky-400' },
          { name: '다이아몬드', min: 70, max: 99, nextMin: 100, icon: 'ph-fill ph-diamond', color: 'text-blue-500' },
          { name: '블랙 다이아몬드', min: 100, max: Infinity, nextMin: 100, icon: 'ph-fill ph-diamond', color: 'text-gray-900 bg-gray-100' },
        ];

        // 2. 현재 등급 정보 찾기
        const currentRank = RANK_TIERS.slice().reverse().find(tier => count >= tier.min);

        if (!currentRank) {
          return RANK_TIERS[0];
        }

        const isMaxRank = currentRank.max === Infinity;

        // 3. 진척도 및 목표치 계산
        let percentageValue = 0;
        let targetCount = currentRank.nextMin;
        let nextRankName = '';
        let nextRankIcon = '';
        let nextRankColor = '';

        if (!isMaxRank) {
          const currentMin = currentRank.min;
          const totalReviewsNeeded = targetCount - currentMin;
          const reviewsDoneInTier = count - currentMin;

          if (totalReviewsNeeded > 0) {
            percentageValue = (reviewsDoneInTier / totalReviewsNeeded) * 100;
          }
          percentageValue = Math.min(99, Math.floor(percentageValue));

          // [NEW] 다음 랭크 정보 찾기
          const nextRankIndex = RANK_TIERS.findIndex(tier => tier.min === currentRank.nextMin);
          if (nextRankIndex !== -1) {
            nextRankName = RANK_TIERS[nextRankIndex].name;
            nextRankIcon = RANK_TIERS[nextRankIndex].icon;
            nextRankColor = RANK_TIERS[nextRankIndex].color;
          }

        } else {
          targetCount = count;
          percentageValue = 100;
        }

        // 4. 최종 결과 반환
        return {
          name: currentRank.name,
          icon: currentRank.icon,
          color: currentRank.color,

          reviewCount: count,
          targetCount: targetCount,
          percentage: percentageValue,
          isMaxRank: isMaxRank,

          // [NEW] 다음 랭크 정보 추가
          nextRankName: nextRankName,
          nextRankIcon: nextRankIcon,
          nextRankColor: nextRankColor,
        };
      });

      const currentRestaurantMenus = computed(() => {
        const restaurantId = selectedRestaurant.value?.id;
        // selectedRestaurant.value.id와 menuMap.value를 사용하여 메뉴 데이터에 접근합니다.
        if (restaurantId && menuMap.value[String(restaurantId)]) {
          return menuMap.value[String(restaurantId)];
        }
        return [];
      });

      const sortedMenus = computed(() => {
        const menus = currentRestaurantMenus.value;
        if (!menus || menus.length === 0) return [];

        // 정렬 로직: is_signature가 true인 메뉴가 false인 메뉴보다 앞에 오도록 정렬합니다.
        // (b.is_signature - a.is_signature)는 true(1)를 false(0)보다 크게 처리하여 내림차순 정렬 효과를 냅니다.
        return [...menus].sort((a, b) => {
          return (b.is_signature - a.is_signature);
        });
      });

      const calculatedPriceDisplay = computed(() => {
        // restaurantForm.menus를 감시하여 평균 가격을 계산
        return calculateAvgPrice(restaurantForm.value.menus);
      });

      const myLikedRestaurants = computed(() => {
        // userLikes Set에 ID가 포함된 식당만 필터링합니다.
        const liked = restaurants.value.filter(r => userLikes.value.has(r.id));

        // 서버에서 좋아요 정보가 로드될 때 created_at 정보도 함께 온다고 가정하고 정렬합니다.
        // 만약 rest 객체에 좋아요 관련 created_at이 없다면, 그냥 리스트 순서대로 반환합니다.
        return liked;

        // NOTE: 현재 JS 코드에서는 개별 식당(rest) 객체에 사용자의 '좋아요 시점(created_at)' 정보가 직접 포함되어 있지 않습니다.
        // 좋아요는 Set(ID만)으로 관리되므로, 서버에서 좋아요 목록을 가져올 때 시점 정보를 포함하도록 API 수정이 필요합니다.
        // 임시로, 리스트에 나타나는 순서대로 반환합니다.
      });

      // [수정] 내 리뷰 리스트 (최신 리뷰 순 정렬)
      const myReviews = computed(() => {
        if (!currentUser.value.email) return [];

        // 1. 내가 작성한 모든 리뷰를 가져와서 정렬합니다. (최신 updated_at 순)
        const reviewsByUser = allReviews.value.filter(
          r => String(r.user_email) === String(currentUser.value.email)
        ).sort((a, b) => {
          const timeA = new Date(b.updated_at || b.created_at).getTime();
          const timeB = new Date(a.updated_at || a.created_at).getTime();
          return timeA - timeB;
        });

        // 2. 각 리뷰에 해당하는 식당 정보를 찾아서 필드를 명확히 합니다.
        return reviewsByUser.map(review => {
          const restaurant = restaurants.value.find(r => r.id === review.restaurant_id);

          // 식당 정보가 없거나 부족할 경우를 대비한 기본값
          const restInfo = restaurant || { name: '삭제된 식당', category: 'N/A', rate: 0, like_count: 0, price: 0 };

          return {
            // 뷰에 필요한 식당 정보
            restaurant_id: restInfo.id,
            name: restInfo.name,
            category: restInfo.category,
            like_count: restInfo.like_count,
            rate: restInfo.rate, // 식당 평균 평점

            // 뷰에 필요한 해당 리뷰 정보
            id: review.id, // 카드의 고유 키 (리뷰 ID)
            review_rate: review.rate, // 이 카드가 보여줄 '나의' 개별 평점
            comment: review.comment, // [수정] 이 카드가 보여줄 '나의' 리뷰 내용
            updated_at: review.updated_at || review.created_at, // 카드에 표시할 업데이트 시간
          };
        });
      });

      // --- Internal Helpers (Data Sync) ---
      const updateReviewAndRestaurantState = (restId, newReview = null, deletedReviewId = null) => {
        const rest = restaurants.value.find(r => r.id === restId);
        if (!rest) return;

        // 1. All Reviews 상태 업데이트 (추가/삭제/수정)
        if (newReview) {
          const index = allReviews.value.findIndex(r => r.id === newReview.id);
          if (index !== -1) {
            allReviews.value.splice(index, 1, newReview);
          } else {
            allReviews.value.unshift(newReview);
          }
        } else if (deletedReviewId) {
          const index = allReviews.value.findIndex(r => r.id === deletedReviewId);
          if (index !== -1) {
            allReviews.value.splice(index, 1);
          }
        }

        // 2. 리뷰 카운트 및 평점 재계산
        const filteredReviews = allReviews.value.filter(r => String(r.restaurant_id) === String(restId));
        const count = filteredReviews.length;
        const sum = filteredReviews.reduce((acc, curr) => acc + Number(curr.rate), 0);
        const avg = count > 0 ? parseFloat((sum / count).toFixed(1)) : 0;

        rest.reviewCount = count;
        rest.rate = avg;
        rest.latestReview = filteredReviews[0]?.comment || null;
        rest.latestReviewRate = filteredReviews[0]?.rate || null;

        // 3. 현재 모달 리뷰 및 필터 캐시 업데이트
        updateCurrentModalReviews(restId);
        updateReviewFilterCache(restId, newReview ? newReview.user_email : currentUser.value.email, deletedReviewId);
      };

      const updateReviewFilterCache = (restId, userEmail, deletedReviewId) => {
        if (userEmail === currentUser.value.email) {
          if (!deletedReviewId) {
            myReviewedRestaurantIds.value.add(restId);
          } else {
            const remaining = allReviews.value.some(r => String(r.restaurant_id) === String(restId) && String(r.user_email) === String(userEmail));
            if (!remaining) {
              myReviewedRestaurantIds.value.delete(restId);
            }
          }
        }
      };

      const updateRestaurantLocalState = (serverData, isEdit) => {
        const existingRest = isEdit ? restaurants.value.find(r => r.id === serverData.id) : null;

        const newRestaurant = {
          id: serverData.id,
          name: restaurantForm.value.name,
          category: restaurantForm.value.category,
          tags: restaurantForm.value.tags,
          signature_menu: serverData.signature_menu, // [수정] 서버에서 온 시그니처 메뉴명 사용
          price: serverData.price, // [수정] 서버에서 온 평균 가격 사용
          rate: existingRest ? existingRest.rate : 0,
          like_count: existingRest ? existingRest.like_count : 0,
          reviewCount: existingRest ? existingRest.reviewCount : 0,
          // enabled, created_at, updated_at 필드는 서버에서 관리된다고 가정
        };

        if (isEdit) {
          const index = restaurants.value.findIndex(r => r.id === serverData.id);
          if (index !== -1) {
            const currentRest = restaurants.value[index];
            restaurants.value.splice(index, 1, { ...currentRest, ...newRestaurant });
            selectedRestaurant.value = restaurants.value[index];
          }
        } else {
          restaurants.value.unshift(newRestaurant);
          selectedRestaurant.value = newRestaurant;
        }
      };

      // -------------------------------

      // --- Methods ---
      const showAlert = (message, title = '알림') => {
        return new Promise(resolve => { alertState.value = { visible: true, type: 'alert', title, message, resolve }; });
      };
      const showConfirm = (message, title = '확인') => {
        return new Promise(resolve => { alertState.value = { visible: true, type: 'confirm', title, message, resolve }; });
      };
      const onAlertConfirm = () => { if (alertState.value.resolve) alertState.value.resolve(true); alertState.value.visible = false; };
      const onAlertCancel = () => { if (alertState.value.resolve) alertState.value.resolve(false); alertState.value.visible = false; };

      const loadData = (callback) => {
        isLoading.value = true;

        // 1. User Data Promise (LOGGING ADDED)
        const userPromise = new Promise(resolve => {
          google.script.run.withSuccessHandler(res => {
            console.log('API Response [apiGetCurrentUser]:', res); // <- NEW LOG
            if (res && res.success) {
              currentUser.value = res.data.email ? res.data : { email: '', isAdmin: false };
            } else {
              currentUser.value = { email: '', isAdmin: false };
            }
            resolve();
          }).apiGetCurrentUser();
        });

        // 2. Restaurant Data Promise (LOGGING ADDED)
        const mainDataPromise = new Promise(resolve => {
          google.script.run.withSuccessHandler(res => {
            console.log('API Response [apiGetRestaurants]:', res); // <- NEW LOG
            if (res && res.success) {
              restaurants.value = res.data; resolve(true);
            }
            else {
              showAlert('식당 리스트 로드 실패: ' + (res?.message || '알 수 없는 오류'));
              resolve(false);
            }
          }).apiGetRestaurants();
        });

        // 3. Review Data Promise (LOGGING ADDED)
        const reviewDataPromise = new Promise(resolve => {
          google.script.run.withSuccessHandler(res => {
            console.log('API Response [apiGetAllReviews]:', res); // <- NEW LOG
            if (res && res.success) {
              allReviews.value = res.data.reviews;

              const userEmail = currentUser.value.email;
              const reviewedIds = new Set();
              if (userEmail) {
                res.data.reviews.forEach(review => {
                  if (String(review.user_email) === String(userEmail)) {
                    reviewedIds.add(review.restaurant_id);
                  }
                });
              }
              myReviewedRestaurantIds.value = reviewedIds;

              resolve(true);
            } else {
              resolve(false);
            }
          }).apiGetAllReviews();
        });

        // 4. Likes Data Promise (LOGGING ADDED)
        const likesPromise = new Promise(resolve => {
          google.script.run.withSuccessHandler(res => {
            console.log('API Response [apiGetUserLikes]:', res); // <- NEW LOG
            if (res && res.success) { userLikes.value = new Set(res.data); }
            resolve();
          }).apiGetUserLikes();
        });

        // 5. Menu Data Promise (LOGGING ADDED)
        const menuDataPromise = new Promise(resolve => {
          google.script.run.withSuccessHandler(res => {
            console.log('API Response [apiGetAllMenus]:', res); // <- NEW LOG
            if (res && res.success) {
              const map = {};
              res.data.forEach(m => {
                if (!map[m.restaurant_id]) map[m.restaurant_id] = [];
                map[m.restaurant_id].push(m);
              });
              menuMap.value = map; // [NEW] menuMap에 캐싱
            }
            resolve();
          }).apiGetAllMenus();
        });

        Promise.all([userPromise, mainDataPromise, reviewDataPromise, likesPromise, menuDataPromise]).then(([u, m, r, l]) => {
          isLoading.value = false;
          if (m && r) {
            mergeReviewsToRestaurants();
            if (modalOpen.value && selectedRestaurant.value.id) {
              const updated = restaurants.value.find(r => r.id === selectedRestaurant.value.id);
              if (updated && (modalMode.value === 'view' || modalMode.value === 'readonly')) selectedRestaurant.value = updated;
            }
            if (callback && typeof callback === 'function') callback();
          }
        });
      };

      const mergeReviewsToRestaurants = () => {
        if (restaurants.value.length === 0) return;

        restaurants.value.forEach(rest => {
          const myReviews = allReviews.value.filter(r => String(r.restaurant_id) === String(rest.id));
          rest.reviewCount = myReviews.length;
          if (myReviews.length > 0) {
            // 최신 리뷰를 찾음 (이미 created_at 기준으로 정렬되어 있다고 가정)
            rest.latestReview = myReviews[0].comment;
            rest.latestReviewRate = myReviews[0].rate;
          } else {
            rest.latestReview = null;
            rest.latestReviewRate = null;
          }
        });
      };

      // [NEW] Like Logic
      const isLiked = (restId) => userLikes.value.has(restId);
      const toggleLikeFilter = () => showLikeFilter.value = !showLikeFilter.value;
      const toggleLike = (rest) => {
        if (!currentUser.value.email) { showAlert('로그인이 필요합니다.'); return; }

        const wasLiked = userLikes.value.has(rest.id);
        if (wasLiked) {
          userLikes.value.delete(rest.id);
          rest.like_count = Math.max(0, (rest.like_count || 0) - 1);
        } else {
          userLikes.value.add(rest.id);
          rest.like_count = (rest.like_count || 0) + 1;
        }

        google.script.run.withSuccessHandler(res => {
          if (!res.success) {
            if (wasLiked) { userLikes.value.add(rest.id); rest.like_count++; }
            else { userLikes.value.delete(rest.id); rest.like_count--; }
            showAlert('찜하기 실패', '처리 실패');
          }
        }).apiToggleLike(rest.id);
      };

      const addLikedToWheel = () => {
        const likedRests = restaurants.value.filter(r => userLikes.value.has(r.id));
        likedRests.forEach(t => addToWheel(t));
      };

      // Modal Methods

      const formatPrice = (price) => {
        if (price === null || price === undefined || price === '') return '가격 정보 없음';

        const numPrice = Number(price);
        if (isNaN(numPrice) || numPrice === 0) return '가격 정보 없음';

        // toLocaleString을 사용하여 천 단위 구분 기호 추가
        return `${numPrice.toLocaleString()}원`;
      };

      const addMenuInput = () => {
        // 새 메뉴 항목을 추가합니다. is_signature는 기본적으로 false로 설정
        // 빈 객체로 시작하여 Vue의 restaurantForm.menus 배열에 추가합니다.
        restaurantForm.value.menus.push({ name: '', price: '', is_signature: false });
      };

      // 메뉴 삭제 함수 (누락 가능성이 있어 함께 추가 권장)
      const removeMenuInput = (index) => {
        // 메뉴 항목을 인덱스를 통해 삭제합니다.
        restaurantForm.value.menus.splice(index, 1);
      };

      const toggleMenuSignature = (index) => {
        // 특정 인덱스의 is_signature 값을 토글합니다.
        const menu = restaurantForm.value.menus[index];
        if (menu) {
          menu.is_signature = !menu.is_signature;
        }
      };

      const cleanNumber = (value) => {
        if (typeof value === 'string') {
          return value.replace(/[^0-9]/g, '');
        }
        return String(value);
      };

      const formatNumberWithCommas = (value) => {
        const cleaned = cleanNumber(value);
        if (!cleaned) return '';
        return Number(cleaned).toLocaleString('ko-KR');
      };

      const calculateAvgPrice = (menus) => {
        if (!menus || menus.length === 0) return 0; // [수정] 텍스트가 아닌 0 반환

        const validPrices = menus
          .map(m => Number(m.price) || 0)
          .filter(p => p > 0);

        if (validPrices.length === 0) return 0;

        const sum = validPrices.reduce((total, price) => total + price, 0);
        const avg = Math.round(sum / validPrices.length);

        // [수정] 순수 평균 숫자만 반환
        return avg;
      };

      const openModal = (restId) => {
        modalMode.value = 'view';

        // 1. 전달받은 ID로 restaurants 배열에서 식당 객체를 찾습니다.
        const rest = restaurants.value.find(r => r.id === restId);

        if (!rest) {
          showAlert('식당 정보를 찾을 수 없습니다.');
          return;
        }

        selectedRestaurant.value = rest;

        // [NEW] 메뉴 데이터 주입 및 정렬
        const cachedMenus = menuMap.value[rest.id] || [];
        cachedMenus.sort((a, b) => (b.is_signature === true) - (a.is_signature === true));
        selectedRestaurant.value.menus = cachedMenus;

        reviewForm.value = { rate: 0, user_name: '', comment: '', restaurant_id: rest.id };
        modalOpen.value = true;
        updateCurrentModalReviews(rest.id);
        showKebabMenu.value = false;
      };
      const openReadOnlyModal = (restId) => { // [수정] 식당 ID(restId)를 직접 인자로 받도록 변경
        modalMode.value = 'readonly';

        const rest = restaurants.value.find(r => r.id === restId);

        if (!rest) {
          showAlert('식당 정보를 찾을 수 없습니다.');
          return;
        }

        selectedRestaurant.value = rest;

        // [NEW] 메뉴 데이터 주입 및 정렬
        const cachedMenus = menuMap.value[rest.id] || [];
        cachedMenus.sort((a, b) => (b.is_signature === true) - (a.is_signature === true));
        selectedRestaurant.value.menus = cachedMenus;

        reviewForm.value = { rate: 0, user_name: '', comment: '', restaurant_id: rest.id };
        modalOpen.value = true;
        updateCurrentModalReviews(rest.id);
        showKebabMenu.value = false;
      };

      const openAddRestaurantModal = () => {
        modalMode.value = 'create';
        restaurantForm.value = {
          id: '', name: '', category: '', tags: [], signature_menu: '', price: '', tagInput: '',
          menus: [{ name: '', price: '', is_signature: true }] // [NEW] 메뉴 초기값 설정
        };
        duplicateList.value = [];
        modalOpen.value = true;
        showKebabMenu.value = false;
      };

      const startEditRestaurant = () => {
        modalMode.value = 'edit';
        const r = selectedRestaurant.value;
        const cachedMenus = menuMap.value[r.id] || [];

        // [NEW] 메뉴 데이터 주입 (is_signature 포함)
        restaurantForm.value = {
          id: r.id, name: r.name, category: r.category, tags: [...r.tags], signature_menu: r.signature_menu, price: r.price, tagInput: '',
          menus: cachedMenus.map(m => ({ name: m.name, price: m.price, is_signature: m.is_signature || false }))
        };

        duplicateList.value = [];
        showKebabMenu.value = false;
      };

      const closeModal = () => {
        if (isSubmitting.value) return;
        modalOpen.value = false;
        cancelEditReview();
        showCategoryDropdown.value = false;
        showKebabMenu.value = false;
      };
      const handleCancel = () => {
        if (isSubmitting.value) return;
        if (modalMode.value === 'edit') {
          modalMode.value = 'view';
          duplicateList.value = [];
        } else {
          closeModal();
        }
      };
      const openUserModal = () => { showUserModal.value = true; };
      const closeUserModal = () => { showUserModal.value = false; };

      const formatReviewComment = (comment) => {
        if (!comment) return '';
        let formatted = comment;
        const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
        formatted = formatted.replace(urlRegex, url => '<a href="' + url + '" target="_blank" class="text-blue-500 hover:text-blue-700 hover:underline">' + url + '</a>');
        return formatted.replace(/\n/g, '<br>');
      };

      const processTagInput = (e) => {
        if (isComposing.value || !restaurantForm.value.tagInput.trim()) return;
        if (e.key === 'Enter' || e.key === ' ' || e.key === ',') {
          e.preventDefault();
          const val = restaurantForm.value.tagInput.trim();
          if (val && !restaurantForm.value.tags.includes(val)) restaurantForm.value.tags.push(val);
          restaurantForm.value.tagInput = '';
        }
      };
      const handleCompositionStart = () => { isComposing.value = true; };
      const handleCompositionEnd = () => { isComposing.value = false; };
      const removeTag = (index) => { restaurantForm.value.tags.splice(index, 1); };
      const openCategoryDropdown = () => { showCategoryDropdown.value = true; focusedCategoryIndex.value = -1; };
      const closeCategoryDropdown = () => { setTimeout(() => { showCategoryDropdown.value = false; focusedCategoryIndex.value = -1; }, 200); };
      const selectCategory = (cat) => { restaurantForm.value.category = cat; showCategoryDropdown.value = false; };
      const onCategoryKeydown = (e) => { if (!showCategoryDropdown.value) { if (e.key === 'ArrowDown') openCategoryDropdown(); return; } const options = filteredCategoryOptions.value; if (e.key === 'ArrowDown') { e.preventDefault(); if (focusedCategoryIndex.value < options.length - 1) focusedCategoryIndex.value++; } else if (e.key === 'ArrowUp') { e.preventDefault(); if (focusedCategoryIndex.value > 0) focusedCategoryIndex.value--; } else if (e.key === 'Enter') { e.preventDefault(); if (focusedCategoryIndex.value >= 0 && focusedCategoryIndex.value < options.length) { selectCategory(options[focusedCategoryIndex.value]); } else if (options.length === 1) { selectCategory(options[0]); } else { showCategoryDropdown.value = false; } } else if (e.key === 'Escape') { showCategoryDropdown.value = false; } };

      watch(() => restaurantForm.value.name, (newName) => {
        if (!newName || (modalMode.value !== 'create' && modalMode.value !== 'edit')) { duplicateList.value = []; return; }
        const normalizedInput = newName.replace(/\s/g, '').toLowerCase();
        const duplicates = restaurants.value.filter(r => {
          if (modalMode.value === 'edit' && r.id === restaurantForm.value.id) return false;
          const normalizedTarget = r.name.replace(/\s/g, '').toLowerCase();
          return normalizedTarget.includes(normalizedInput);
        });
        duplicateList.value = duplicates;
      });

      const saveRestaurant = async () => {
        if (!restaurantForm.value.name) { showAlert('상호명을 입력해주세요.'); return; }
        if (!restaurantForm.value.category) { showAlert('카테고리를 입력하거나 선택해주세요.'); return; }
        if (duplicateList.value.length > 0) {
          const confirmSave = await showConfirm(`유사한 상호명이 ${duplicateList.value.length}개 존재합니다.\n그래도 저장하시겠습니까?`);
          if (!confirmSave) return;
        }

        isSubmitting.value = true;
        const isEdit = modalMode.value === 'edit';
        const apiFunc = !isEdit ? 'apiAddRestaurant' : 'apiUpdateRestaurant';

        console.log('DEBUG PAYLOAD [originMenus]:', restaurantForm.value.menus);

        // [NEW] 메뉴 데이터 전처리 및 payload 구성
        const cleanMenus = restaurantForm.value.menus
          .filter(m => m.name && m.name.trim() !== '')
          .map(m => ({
            name: m.name.trim(),
            price: Number(m.price) || 0,
            is_signature: m.is_signature || false
          }));
        console.log('DEBUG PAYLOAD [cleanMenus]:', cleanMenus);

        // [NEW] payload에 menus 필드 추가
        const payload = { ...restaurantForm.value, menus: cleanMenus };

        if (Object.prototype.hasOwnProperty.call(payload, 'signature_menu')) {
          delete payload.signature_menu;
        }

        console.log('DEBUG PAYLOAD [Full]:', payload);

        // 서버 요청
        google.script.run.withSuccessHandler(res => {
          if (res.success && res.data) {

            // [NEW] menuMap 캐시 업데이트
            const updatedMenus = cleanMenus.map(m => ({
              restaurant_id: String(res.data.id),
              name: m.name, price: m.price, is_signature: m.is_signature
            }));
            menuMap.value[String(res.data.id)] = updatedMenus; // 캐시 저장

            // [NEW] 로컬 상태 업데이트
            updateRestaurantLocalState(res.data, isEdit);

            isSubmitting.value = false;

            if (isEdit) {
              modalMode.value = 'view';
            } else {
              modalMode.value = 'view';
              reviewForm.value = { rate: 0, user_name: '', comment: '', restaurant_id: selectedRestaurant.value.id };
              updateCurrentModalReviews(selectedRestaurant.value.id);
            }
          } else {
            isSubmitting.value = false;
            showAlert('식당 정보 저장에 실패했습니다.', '처리 실패');
          }
        })[apiFunc](payload); // [수정] payload 사용
      };

      const deleteRestaurant = async () => {
        const confirmed = await showConfirm('정말 이 식당 정보를 삭제하시겠습니까?');
        if (!confirmed) return;

        isSubmitting.value = true;
        const idToDelete = modalMode.value === 'edit' ? restaurantForm.value.id : selectedRestaurant.value.id;

        google.script.run.withSuccessHandler(res => {
          if (res.success) {

            const index = restaurants.value.findIndex(r => r.id === idToDelete);
            if (index !== -1) {
              restaurants.value.splice(index, 1);
            }
            // [NEW] 메뉴 캐시에서도 삭제
            delete menuMap.value[idToDelete];

            isSubmitting.value = false;
            closeModal();
          } else {
            isSubmitting.value = false;
            showAlert('식당 삭제에 실패했습니다.', '처리 실패');
          }
        }).apiDeleteRestaurant(idToDelete);
      };

      const updateCurrentModalReviews = (restId) => {
        try {
          let filtered = allReviews.value.filter(r => String(r.restaurant_id) === String(restId));
          filtered.sort((a, b) => {
            const timeA = a.created_at ? new Date(a.created_at).getTime() : 0;
            const timeB = b.created_at ? new Date(b.created_at).getTime() : 0;
            if (timeA !== timeB) return timeB - timeA;
            const idA = String(a.id || ''), idB = String(b.id || '');
            return idB.localeCompare(idA, undefined, { numeric: true });
          });
          reviews.value = filtered;
        } catch (e) {
          reviews.value = allReviews.value.filter(r => String(r.restaurant_id) === String(restId));
        }
      };

      const submitReview = async () => {
        if (!reviewForm.value.rate || reviewForm.value.rate < 1) { showAlert('별점을 선택해주세요.'); return; }
        if (!reviewForm.value.user_name) { showAlert('작성자를 입력해주세요.'); return; }
        if (!reviewForm.value.comment) { showAlert('내용을 입력해주세요.'); return; }
        isSubmitting.value = true;

        google.script.run.withSuccessHandler(res => {
          if (res.success && res.data) {
            const newReviewData = {
              id: res.data.id,
              restaurant_id: selectedRestaurant.value.id,
              rate: reviewForm.value.rate,
              comment: reviewForm.value.comment,
              user_name: reviewForm.value.user_name,
              user_email: currentUser.value.email,
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString(),
            };

            updateReviewAndRestaurantState(selectedRestaurant.value.id, newReviewData);

            reviewForm.value = { rate: 0, user_name: '', comment: '', restaurant_id: selectedRestaurant.value.id };
            highlightReviewId.value = newReviewData.id;
            setTimeout(() => { highlightReviewId.value = null; }, 2000);
            isSubmitting.value = false;

          } else {
            isSubmitting.value = false;
            showAlert('리뷰 등록에 실패했습니다.', '처리 실패');
          }
        }).apiAddReview(reviewForm.value);
      };

      const deleteReview = async (reviewId) => {
        const confirmed = await showConfirm('정말 이 리뷰를 삭제하시겠습니까?');
        if (!confirmed) return;
        isSubmitting.value = true;

        google.script.run.withSuccessHandler(res => {
          if (res.success) {
            updateReviewAndRestaurantState(selectedRestaurant.value.id, null, reviewId);

            isSubmitting.value = false;
          } else {
            isSubmitting.value = false;
            showAlert('리뷰 삭제에 실패했습니다.', '처리 실패');
          }
        }).apiDeleteReview(reviewId);
      };

      const startEditReview = (review) => { editingReviewId.value = review.id; editForm.value = { id: review.id, rate: review.rate, comment: review.comment }; };
      const cancelEditReview = () => { editingReviewId.value = null; editForm.value = { id: '', rate: 0, comment: '' }; };
      const saveEditReview = async () => {
        if (!editForm.value.comment) { showAlert('코멘트를 입력해주세요.'); return; }
        isReviewSubmitting.value = true;

        google.script.run.withSuccessHandler(res => {
          if (res.success) {
            const editedReview = {
              id: editForm.value.id,
              restaurant_id: selectedRestaurant.value.id,
              rate: editForm.value.rate,
              comment: editForm.value.comment,
              user_name: reviews.value.find(r => r.id === editForm.value.id)?.user_name || '',
              user_email: currentUser.value.email,
              created_at: reviews.value.find(r => r.id === editForm.value.id)?.created_at || new Date().toISOString(),
              updated_at: new Date().toISOString(),
            };

            updateReviewAndRestaurantState(selectedRestaurant.value.id, editedReview);

            cancelEditReview();
            highlightReviewId.value = editedReview.id;
            setTimeout(() => { highlightReviewId.value = null; }, 2000);
            isReviewSubmitting.value = false;

          } else {
            isReviewSubmitting.value = false;
            showAlert('리뷰 수정에 실패했습니다.', '처리 실패');
          }
        }).apiUpdateReview(editForm.value);
      };

      const canManageReview = (review) => { if (currentUser.value.isAdmin) return true; if (currentUser.value.email && String(review.user_email) === String(currentUser.value.email)) return true; return false; };

      const updateTooltip = (e, rest) => {
        if (windowWidth.value < 768) return;
        let x = e.clientX + 10; let y = e.clientY + 10;
        if (x + 250 > window.innerWidth) x = e.clientX - 250;
        if (y + 150 > window.innerHeight) y = e.clientY - 150;
        tooltipData.value = rest; tooltipVisible.value = true; tooltipPos.value = { x: x, y: y };
      };
      const hideTooltip = () => tooltipVisible.value = false;
      const toggleFilter = () => isFilterOpen.value = !isFilterOpen.value;
      const toggleFilterItem = (type, value) => { const idx = filters.value[type].indexOf(value); if (idx === -1) filters.value[type].push(value); else filters.value[type].splice(idx, 1); currentPage.value = 1; };

      // [NEW] 툴팁용: 메뉴를 정렬하고 포맷하여 문자열로 반환 (시그니처 우선, 최대 3개)
      const getFormattedMenuString = (menus) => {
        if (!menus || menus.length === 0) return '메뉴 정보 없음';

        // 시그니처 우선 정렬 (b.is_signature - a.is_signature)
        const sorted = [...menus].sort((a, b) => (b.is_signature - a.is_signature));

        // 상위 3개 메뉴를 "메뉴명 (가격)" 형식으로 포맷
        return sorted.slice(0, 3)
          .map(m => `${m.name} (${formatPrice(m.price)})`)
          .join(', ');
      };

      const setSort = (field) => {
        if (sort.value.field === field) {
          if (sort.value.order === 'desc') sort.value.order = 'asc';
          else if (sort.value.order === 'asc') sort.value.order = null;
          else sort.value.order = 'desc';
        } else {
          sort.value.field = field; sort.value.order = 'desc';
        }
      };
      const setSortOrder = () => {
        if (!sort.value.field || sort.value.order === null) { sort.value.field = 'name'; sort.value.order = 'desc'; }
        else if (sort.value.order === 'desc') { sort.value.order = 'asc'; }
        else { sort.value.order = 'desc'; }
      };
      const getSortIcon = (field) => {
        if (sort.value.field !== field || !sort.value.order) return 'ph ph-arrows-down-up text-gray-400';
        return sort.value.order === 'desc' ? 'ph ph-caret-down' : 'ph ph-caret-up';
      };

      const toggleSortDropdown = () => {
        sortDropdownOpen.value = !sortDropdownOpen.value;
      };
      const togglePageSizeDropdown = () => {
        pageSizeDropdownOpen.value = !pageSizeDropdownOpen.value;
      };

      const addCategoryToWheel = (val) => {
        let toAdd = [];
        if (val === '밖밥파') {
          toAdd = restaurants.value.filter(rest => {
            const isDelivery = (rest.category && rest.category === '배달') || (rest.tags && rest.tags.some(t => t.includes('배달')));
            return !isDelivery;
          });
        } else {
          toAdd = restaurants.value.filter(r => r.category === val || (r.tags && r.tags.includes(val)));
        }
        toAdd.forEach(t => addToWheel(t));
      };
      const addAllToWheel = () => restaurants.value.forEach(t => addToWheel(t));
      const addToWheel = (item) => { if (!wheelItems.value.find(w => w.id === item.id)) { wheelItems.value.push(item); wheelSearch.value = ''; drawWheel(); } };
      const removeFromWheel = (index) => { wheelItems.value.splice(index, 1); drawWheel(); };
      const clearWheel = () => { wheelItems.value = []; drawWheel(); };
      const resetWheel = () => { winner.value = null; wheelRotation = 0; pinAngle = 0; drawWheel(); };

      const drawWheel = () => {
        const canvas = document.getElementById('wheelCanvas'); if (!canvas) return; const ctx = canvas.getContext('2d');
        const width = canvas.width, height = canvas.height; const verticalOffset = 20; const radius = width / 2 - 30; const centerX = width / 2, centerY = height / 2 + verticalOffset;
        ctx.clearRect(0, 0, width, height);
        if (wheelItems.value.length === 0) { ctx.fillStyle = '#f3f4f6'; ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI); ctx.fill(); ctx.fillStyle = '#9ca3af'; ctx.font = '20px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('후보 리스트를 추가하세요', centerX, centerY); return; }
        const step = (2 * Math.PI) / wheelItems.value.length; const colors = ['#fca5a5', '#fdba74', '#fcd34d', '#86efac', '#93c5fd', '#c4b5fd', '#f9a8d4'];
        ctx.save(); ctx.translate(centerX, centerY); ctx.rotate(wheelRotation);
        for (let i = 0; i < wheelItems.value.length; i++) {
          const angle = i * step;
          ctx.beginPath(); ctx.moveTo(0, 0); ctx.arc(0, 0, radius, angle, angle + step); ctx.fillStyle = colors[i % colors.length]; ctx.fill(); ctx.stroke();
          ctx.save(); ctx.rotate(angle); ctx.beginPath(); ctx.arc(radius, 0, 3, 0, 2 * Math.PI); ctx.fillStyle = 'white'; ctx.fill(); ctx.strokeStyle = '#d1d5db'; ctx.stroke(); ctx.restore();
          ctx.save(); ctx.rotate(angle + step / 2); ctx.textAlign = 'right'; ctx.fillStyle = '#374151'; ctx.font = 'bold 14px sans-serif'; ctx.fillText(wheelItems.value[i].name, radius - 20, 5); ctx.restore();
        }
        ctx.restore();
        ctx.beginPath(); ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI); ctx.fillStyle = '#6b7280'; ctx.fill();
        ctx.save(); ctx.translate(centerX, 5 + verticalOffset); ctx.rotate(pinAngle); ctx.beginPath(); ctx.arc(0, 0, 8, Math.PI, 0); ctx.lineTo(0, 30); ctx.lineTo(-8, 0); ctx.closePath(); ctx.fillStyle = '#dc2626'; ctx.fill(); ctx.strokeStyle = '#991b1b'; ctx.lineWidth = 1; ctx.stroke(); ctx.beginPath(); ctx.arc(0, 0, 3, 0, 2 * Math.PI); ctx.fillStyle = '#fca5a5'; ctx.fill(); ctx.restore();
      };

      const spinWheel = () => {
        if (isSpinning.value || wheelItems.value.length === 0) return;
        isSpinning.value = true; winner.value = null; wheelVelocity = 0.4 + Math.random() * 0.1;
        const segAngle = (2 * Math.PI) / wheelItems.value.length; const pointerAngle = 1.5 * Math.PI; prevIndex = 0;
        const animate = () => {
          wheelVelocity *= 0.99; wheelRotation += wheelVelocity;
          const normalizedRot = wheelRotation % (2 * Math.PI);
          const currentRelativeAngle = (pointerAngle - normalizedRot + (2 * Math.PI)) % (2 * Math.PI);
          const currentIndex = Math.floor(currentRelativeAngle / segAngle);
          if (currentIndex !== prevIndex) { pinVelocity -= pinKick; }
          prevIndex = currentIndex;
          pinVelocity += (0 - pinAngle) * pinSpring; pinVelocity *= pinDamping; pinAngle += pinVelocity;
          pinAngle = Math.max(-Math.PI / 18, Math.min(Math.PI / 3, pinAngle));
          drawWheel();
          if (wheelVelocity < 0.002) { isSpinning.value = false; cancelAnimationFrame(animationId); calculateWinner(); pinAngle = 0; drawWheel(); } else { animationId = requestAnimationFrame(animate); }
        };
        animate();
      };
      const calculateWinner = () => { const normRot = wheelRotation % (2 * Math.PI); const segAngle = (2 * Math.PI) / wheelItems.value.length; let ptrAngle = (1.5 * Math.PI) - normRot; if (ptrAngle < 0) ptrAngle += 2 * Math.PI; winner.value = wheelItems.value[Math.floor(ptrAngle / segAngle) % wheelItems.value.length]; };

      const formatDate = (dateStr) => { if (!dateStr) return ''; const d = new Date(dateStr); return `${d.getFullYear()}.${d.getMonth() + 1}.${d.getDate()}`; };
      const updateWidth = () => windowWidth.value = window.innerWidth;

      const toggleKebabMenu = () => {
        showKebabMenu.value = !showKebabMenu.value;
      };

      const handleMenuPriceInput = (menuItem, newFormattedValue) => {
        const cleanedValue = cleanNumber(newFormattedValue);
        menuItem.price = parseInt(cleanedValue) || 0;
      };

      const formatDateTime = (dateStr) => {
        if (!dateStr) return '';
        try {
          const d = new Date(dateStr);
          const datePart = `${d.getFullYear()}-${(d.getMonth() + 1).toString().padStart(2, '0')}-${d.getDate().toString().padStart(2, '0')}`;
          const timePart = `${d.getHours().toString().padStart(2, '0')}:${d.getMinutes().toString().padStart(2, '0')}:${d.getSeconds().toString().padStart(2, '0')}`;
          return `${datePart} ${timePart}`;
        } catch (e) {
          return '날짜 오류';
        }
      };

      // --- Watchers ---
      watch(isLoading, (newVal, oldVal) => {
        if (oldVal === true && newVal === false) {
          nextTick(() => {
            if (windowWidth.value >= 768) {
              isFilterOpen.value = true;
            }
          });
        }
      });

      onMounted(() => {
        loadData();
        window.addEventListener('resize', updateWidth);
        watch(currentTab, (newVal) => { if (newVal === 'wheel') nextTick(() => drawWheel()); });

        window.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            if (isSubmitting.value) return;

            if (showKebabMenu.value) {
              showKebabMenu.value = false;
              return;
            }

            if (sortDropdownOpen.value) { sortDropdownOpen.value = false; return; }
            if (pageSizeDropdownOpen.value) { pageSizeDropdownOpen.value = false; return; }

            if (alertState.value.visible) onAlertCancel();

            else if (showUserModal.value) closeUserModal();

            else if (modalOpen.value) {
              if (modalMode.value === 'view' || modalMode.value === 'readonly') closeModal();
            }
          }
        });

        watch(modalOpen, (val) => {
          document.body.style.overflow = val ? 'hidden' : 'auto';
          showKebabMenu.value = false;
        });

        watchEffect(() => {
          restaurantForm.value.price = calculatedPriceDisplay.value;
        });

        document.addEventListener('click', (e) => {
          const button = kebabButton.value;
          if (showKebabMenu.value && button && !button.contains(e.target)) {
            let target = e.target;
            let isKebabMenuClicked = false;
            while (target) {
              if (target.classList && target.classList.contains('kebab-dropdown')) {
                isKebabMenuClicked = true;
                break;
              }
              target = target.parentNode;
            }
            if (!isKebabMenuClicked) {
              showKebabMenu.value = false;
            }
          }

          if (sortDropdownOpen.value) {
            if (!e.target.closest('.js-sort-dropdown')) {
              sortDropdownOpen.value = false;
            }
          }

          if (pageSizeDropdownOpen.value) {
            if (!e.target.closest('.js-pagesize-dropdown')) {
              pageSizeDropdownOpen.value = false;
            }
          }
        });
      });

      return {
        restaurants, currentTab, pageSize, currentPage, isLoading, currentUser, userInitial, userId, userReviewCount, userRankInfo,
        isFilterOpen, filters, toggleFilter, toggleFilterItem, uniqueCategories, uniqueTags,
        filteredRestaurants, paginatedRestaurants, totalPages, sort, setSort, setSortOrder, getSortIcon,
        modalOpen, modalMode, selectedRestaurant, restaurantForm, duplicateList, isNewCategory, filteredCategoryOptions, showCategoryDropdown, focusedCategoryIndex,
        openModal, openReadOnlyModal, openAddRestaurantModal, startEditRestaurant, closeModal, processTagInput, handleCompositionStart, handleCompositionEnd, isComposing, removeTag, saveRestaurant, deleteRestaurant,
        openCategoryDropdown, closeCategoryDropdown, selectCategory, onCategoryKeydown,
        reviews, reviewForm, isSubmitting, submitReview, deleteReview, canManageReview, startEditReview, cancelEditReview, saveEditReview, highlightReviewId, editingReviewId, editForm, isReviewSubmitting, hoverRate, formatDate,
        wheelItems, wheelSearch, addToWheel, removeFromWheel, spinWheel, isSpinning, winner, addCategoryToWheel, addAllToWheel, clearWheel, filteredWheelCandidates, resetWheel, isWheelListExpanded,
        tooltipVisible, tooltipData, tooltipPos, updateTooltip, hideTooltip, alertState, onAlertConfirm, onAlertCancel, windowWidth, menuMap,
        showUserModal, openUserModal, closeUserModal, searchQuery,
        GOOGLE_SHEET_URL, BASE_WEBAPP_URL, handleCancel, formatReviewComment,
        userLikes, isLiked, toggleLike, showLikeFilter, toggleLikeFilter,
        showMyReviewsFilter, showPendingReviewsFilter,
        addLikedToWheel,
        myReviewedRestaurantIds,
        showKebabMenu,
        toggleKebabMenu,
        kebabButton,
        sortDropdownOpen, pageSizeDropdownOpen, toggleSortDropdown, togglePageSizeDropdown,
        toggleMenuSignature, formatPrice, addMenuInput, removeMenuInput, sortedMenus, handleMenuPriceInput, formatNumberWithCommas, calculatedPriceDisplay,
        getFormattedMenuString,
        myPageTab, myLikedRestaurants, myReviews, formatDateTime
      };
    }
  }).mount('#app');
</script>